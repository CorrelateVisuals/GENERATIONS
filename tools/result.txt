#define STB_IMAGE_IMPLEMENTATION
#include <stb_image.h>

#include "BaseClasses.h"
#include "Library.h"

#include <algorithm>
#include <set>

CE::Device* CE::Device::baseDevice = nullptr;
std::vector<VkDevice> CE::Device::destroyedDevices;
VkCommandBuffer CE::CommandBuffers::singularCommandBuffer = VK_NULL_HANDLE;

VkDescriptorPool CE::Descriptor::pool;
VkDescriptorSetLayout CE::Descriptor::setLayout;
std::array<VkDescriptorSet, MAX_FRAMES_IN_FLIGHT> CE::Descriptor::sets;
std::vector<VkDescriptorPoolSize> CE::Descriptor::poolSizes;
std::array<VkDescriptorSetLayoutBinding, NUM_DESCRIPTORS>
    CE::Descriptor::setLayoutBindings;

size_t CE::Descriptor::writeIndex{0};
std::array<std::array<VkWriteDescriptorSet, NUM_DESCRIPTORS>,
           MAX_FRAMES_IN_FLIGHT>
    CE::Descriptor::descriptorWrites;

void CE::Device::createLogicalDevice(const InitializeVulkan& initVulkan,
                                     Queues& queues) {
  Log::text("{ +++ }", "Logical Device");

  std::vector<VkDeviceQueueCreateInfo> queueCreateInfos =
      fillQueueCreateInfos(queues);
  VkDeviceCreateInfo createInfo = getDeviceCreateInfo(queueCreateInfos);
  setValidationLayers(initVulkan, createInfo);

  CE::VULKAN_RESULT(vkCreateDevice, this->physical, &createInfo, nullptr,
                    &this->logical);
  vkGetDeviceQueue(this->logical,
                   queues.familyIndices.graphicsAndComputeFamily.value(), 0,
                   &queues.graphics);
  vkGetDeviceQueue(this->logical,
                   queues.familyIndices.graphicsAndComputeFamily.value(), 0,
                   &queues.compute);
  vkGetDeviceQueue(this->logical, queues.familyIndices.presentFamily.value(), 0,
                   &queues.present);
}

void CE::Device::pickPhysicalDevice(const InitializeVulkan& initVulkan,
                                    Queues& queues,
                                    Swapchain& swapchain) {
  Log::text("{ ### }", "Physical Device");
  std::vector<VkPhysicalDevice> devices = fillDevices(initVulkan);

  for (const auto& device : devices) {
    if (isDeviceSuitable(device, queues, initVulkan, swapchain)) {
      this->physical = device;
      getMaxUsableSampleCount();
      Log::text(Log::Style::charLeader,
                Log::getSampleCountString(this->maxUsableSampleCount));
      break;
    }
  }
  if (this->physical == VK_NULL_HANDLE) {
    throw std::runtime_error("\n!ERROR! failed to find a suitable GPU!");
  }
}

const std::vector<VkDeviceQueueCreateInfo> CE::Device::fillQueueCreateInfos(
    const Queues& queues) const {
  std::vector<VkDeviceQueueCreateInfo> queueCreateInfos{};
  std::set<uint32_t> uniqueQueueFamilies = {
      queues.familyIndices.graphicsAndComputeFamily.value(),
      queues.familyIndices.presentFamily.value()};

  float queuePriority = 1.0f;
  for (uint_fast8_t queueFamily : uniqueQueueFamilies) {
    VkDeviceQueueCreateInfo queueCreateInfo{
        .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
        .queueFamilyIndex = queueFamily,
        .queueCount = 1,
        .pQueuePriorities = &queuePriority};
    queueCreateInfos.push_back(queueCreateInfo);
  }
  return queueCreateInfos;
}

const VkDeviceCreateInfo CE::Device::getDeviceCreateInfo(
    const std::vector<VkDeviceQueueCreateInfo>& queueCreateInfos) const {
  VkDeviceCreateInfo createInfo{
      .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
      .queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size()),
      .pQueueCreateInfos = queueCreateInfos.data(),
      .enabledLayerCount = 0,
      .enabledExtensionCount = static_cast<uint32_t>(this->extensions.size()),
      .ppEnabledExtensionNames = this->extensions.data(),
      .pEnabledFeatures = &this->features};
  return createInfo;
}

void CE::Device::setValidationLayers(const InitializeVulkan& initVulkan,
                                     VkDeviceCreateInfo& createInfo) {
  if (initVulkan.validation.enableValidationLayers) {
    createInfo.enabledLayerCount =
        static_cast<uint32_t>(initVulkan.validation.validation.size());
    createInfo.ppEnabledLayerNames = initVulkan.validation.validation.data();
  }
}

const std::vector<VkPhysicalDevice> CE::Device::fillDevices(
    const InitializeVulkan& initVulkan) const {
  uint32_t deviceCount(0);
  vkEnumeratePhysicalDevices(initVulkan.instance, &deviceCount, nullptr);

  if (deviceCount == 0) {
    throw std::runtime_error(
        "\n!ERROR! failed to find GPUs with Vulkan support!");
  }

  std::vector<VkPhysicalDevice> devices(deviceCount);
  vkEnumeratePhysicalDevices(initVulkan.instance, &deviceCount, devices.data());
  return devices;
}

const bool CE::Device::isDeviceSuitable(const VkPhysicalDevice& physical,
                                        Queues& queues,
                                        const InitializeVulkan& initVulkan,
                                        Swapchain& swapchain) {
  Log::text(Log::Style::charLeader, "Is Device Suitable");

  queues.familyIndices = queues.findQueueFamilies(physical, initVulkan.surface);
  bool extensionsSupported = checkDeviceExtensionSupport(physical);

  bool swapchainAdequate = false;
  if (extensionsSupported) {
    Swapchain::SupportDetails swapchainSupport =
        swapchain.checkSupport(physical, initVulkan.surface);
    swapchainAdequate = !swapchainSupport.formats.empty() &&
                        !swapchainSupport.presentModes.empty();
  }
  return queues.familyIndices.isComplete() && extensionsSupported &&
         swapchainAdequate;
}

void CE::Device::getMaxUsableSampleCount() {
  vkGetPhysicalDeviceProperties(this->physical, &this->properties);
  VkSampleCountFlags counts =
      this->properties.limits.framebufferColorSampleCounts &
      this->properties.limits.framebufferDepthSampleCounts;
  for (uint_fast8_t i = VK_SAMPLE_COUNT_64_BIT; i >= VK_SAMPLE_COUNT_1_BIT;
       i >>= 1) {
    if (counts & i) {
      this->maxUsableSampleCount = static_cast<VkSampleCountFlagBits>(i);
      return;
    } else {
      this->maxUsableSampleCount = VK_SAMPLE_COUNT_1_BIT;
    }
  }
  return;
}

const bool CE::Device::checkDeviceExtensionSupport(
    const VkPhysicalDevice& physical) const {
  Log::text(Log::Style::charLeader, "Check Device Extension Support");
  uint32_t extensionCount(0);
  vkEnumerateDeviceExtensionProperties(physical, nullptr, &extensionCount,
                                       nullptr);

  std::vector<VkExtensionProperties> availableExtensions(extensionCount);
  vkEnumerateDeviceExtensionProperties(physical, nullptr, &extensionCount,
                                       availableExtensions.data());

  std::set<std::string> requiredExtensions(this->extensions.begin(),
                                           this->extensions.end());

  for (const auto& extension : availableExtensions) {
    requiredExtensions.erase(extension.extensionName);
  }
  return requiredExtensions.empty();
}

const uint32_t CE::findMemoryType(const uint32_t typeFilter,
                                  const VkMemoryPropertyFlags properties) {
  VkPhysicalDeviceMemoryProperties memProperties{};
  vkGetPhysicalDeviceMemoryProperties(Device::baseDevice->physical,
                                      &memProperties);

  for (uint32_t i = 0; i < memProperties.memoryTypeCount; i++) {
    if ((typeFilter & (1 << i)) && (memProperties.memoryTypes[i].propertyFlags &
                                    properties) == properties) {
      return i;
    }
  }
  throw std::runtime_error("\n!ERROR! failed to find suitable memory type!");
}

CE::Buffer::~Buffer() {
  if (Device::baseDevice) {
    if (this->buffer != VK_NULL_HANDLE) {
      vkDestroyBuffer(Device::baseDevice->logical, this->buffer, nullptr);
      this->buffer = VK_NULL_HANDLE;
    }
    if (this->memory != VK_NULL_HANDLE) {
      vkFreeMemory(Device::baseDevice->logical, this->memory, nullptr);
      this->memory = VK_NULL_HANDLE;
    }
  }
}

void CE::Buffer::create(const VkDeviceSize& size,
                        const VkBufferUsageFlags& usage,
                        const VkMemoryPropertyFlags& properties,
                        Buffer& buffer) {
  VkBufferCreateInfo bufferInfo{.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
                                .size = size,
                                .usage = usage,
                                .sharingMode = VK_SHARING_MODE_EXCLUSIVE};
  Log::text("{ ... }", Log::getBufferUsageString(usage));
  Log::text(Log::Style::charLeader, Log::getMemoryPropertyString(properties));
  Log::text(Log::Style::charLeader, size, "bytes");

  CE::VULKAN_RESULT(vkCreateBuffer, Device::baseDevice->logical, &bufferInfo,
                    nullptr, &buffer.buffer);

  VkMemoryRequirements memRequirements{};
  vkGetBufferMemoryRequirements(Device::baseDevice->logical, buffer.buffer,
                                &memRequirements);

  VkMemoryAllocateInfo allocateInfo{
      .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
      .allocationSize = memRequirements.size,
      .memoryTypeIndex =
          CE::findMemoryType(memRequirements.memoryTypeBits, properties)};

  CE::VULKAN_RESULT(vkAllocateMemory, Device::baseDevice->logical,
                    &allocateInfo, nullptr, &buffer.memory);
  vkBindBufferMemory(Device::baseDevice->logical, buffer.buffer, buffer.memory,
                     0);
}

void CE::Buffer::copy(const VkBuffer& srcBuffer,
                      VkBuffer& dstBuffer,
                      const VkDeviceSize size,
                      VkCommandBuffer& commandBuffer,
                      const VkCommandPool& commandPool,
                      const VkQueue& queue) {
  Log::text("{ ... }", "copying", size, "bytes");

  CE::CommandBuffers::beginSingularCommands(commandPool, queue);
  VkBufferCopy copyRegion{.size = size};
  vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, 1, &copyRegion);
  CE::CommandBuffers::endSingularCommands(commandPool, queue);
}

void CE::Buffer::copyToImage(const VkBuffer& buffer,
                             VkImage& image,
                             const uint32_t width,
                             const uint32_t height,
                             VkCommandBuffer& commandBuffer,
                             const VkCommandPool& commandPool,
                             const VkQueue& queue) {
  Log::text("{ img }", "Buffer To Image", width, height);

  CE::CommandBuffers::beginSingularCommands(commandPool, queue);
  VkBufferImageCopy region{.bufferOffset = 0,
                           .bufferRowLength = 0,
                           .bufferImageHeight = 0,
                           .imageOffset = {0, 0, 0},
                           .imageExtent = {width, height, 1}};
  region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
  region.imageSubresource.mipLevel = 0,
  region.imageSubresource.baseArrayLayer = 0,
  region.imageSubresource.layerCount = 1,

  vkCmdCopyBufferToImage(commandBuffer, buffer, image,
                         VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region);
  CE::CommandBuffers::endSingularCommands(commandPool, queue);
}

void CE::Image::destroyVulkanImages() const {
  if (Device::baseDevice && this->memory) {
    if (this->sampler != VK_NULL_HANDLE) {
      vkDestroySampler(Device::baseDevice->logical, this->sampler, nullptr);
    };
    if (this->view != VK_NULL_HANDLE) {
      vkDestroyImageView(Device::baseDevice->logical, this->view, nullptr);
    };
    if (this->image != VK_NULL_HANDLE) {
      vkDestroyImage(Device::baseDevice->logical, this->image, nullptr);
    };
    if (this->memory != VK_NULL_HANDLE) {
      vkFreeMemory(Device::baseDevice->logical, this->memory, nullptr);
    };
  };
}

void CE::Image::create(const uint32_t width,
                       const uint32_t height,
                       const VkSampleCountFlagBits numSamples,
                       const VkFormat format,
                       const VkImageTiling tiling,
                       const VkImageUsageFlags& usage,
                       const VkMemoryPropertyFlags& properties) {
  Log::text("{ img }", "Image", width, height);
  Log::text(Log::Style::charLeader, Log::getSampleCountString(numSamples));
  Log::text(Log::Style::charLeader, Log::getImageUsageString(usage));
  Log::text(Log::Style::charLeader, Log::getMemoryPropertyString(properties));

  info.format = format;
  info.extent = {.width = width, .height = height, .depth = 1};
  info.mipLevels = 1;
  info.arrayLayers = 1;
  info.samples = numSamples;
  info.tiling = tiling;
  info.usage = usage;

  CE::VULKAN_RESULT(vkCreateImage, Device::baseDevice->logical, &this->info,
                    nullptr, &this->image);

  VkMemoryRequirements memRequirements{};
  vkGetImageMemoryRequirements(Device::baseDevice->logical, this->image,
                               &memRequirements);

  VkMemoryAllocateInfo allocateInfo{
      .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
      .allocationSize = memRequirements.size,
      .memoryTypeIndex =
          findMemoryType(memRequirements.memoryTypeBits, properties)};

  CE::VULKAN_RESULT(vkAllocateMemory, Device::baseDevice->logical,
                    &allocateInfo, nullptr, &this->memory);
  vkBindImageMemory(Device::baseDevice->logical, this->image, this->memory, 0);
}

void CE::Image::createView(const VkImageAspectFlags aspectFlags) {
  Log::text(Log::Style::charLeader, "Image View");

  VkImageViewCreateInfo viewInfo{
      .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
      .image = this->image,
      .viewType = VK_IMAGE_VIEW_TYPE_2D,
      .format = this->info.format,
      .subresourceRange = {.aspectMask = aspectFlags,
                           .baseMipLevel = 0,
                           .levelCount = 1,
                           .baseArrayLayer = 0,
                           .layerCount = 1}};

  CE::VULKAN_RESULT(vkCreateImageView, Device::baseDevice->logical, &viewInfo,
                    nullptr, &this->view);
  return;
}

void CE::Image::transitionLayout(const VkCommandBuffer& commandBuffer,
                                 const VkFormat format,
                                 const VkImageLayout oldLayout,
                                 const VkImageLayout newLayout) {
  VkImageMemoryBarrier barrier{.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
                               .oldLayout = oldLayout,
                               .newLayout = newLayout,
                               .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
                               .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
                               .image = this->image};
  barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
  barrier.subresourceRange.baseMipLevel = 0;
  barrier.subresourceRange.levelCount = 1;
  barrier.subresourceRange.baseArrayLayer = 0;
  barrier.subresourceRange.layerCount = 1;

  VkPipelineStageFlags sourceStage{};
  VkPipelineStageFlags destinationStage{};

  if (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED &&
      newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) {
    barrier.srcAccessMask = 0;
    barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
    sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
    destinationStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
  } else if (oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL &&
             newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) {
    barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
    barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

    sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
    destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT |
                       VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT;
  } else {
    // throw std::invalid_argument("unsupported layout transition!");

    barrier.srcAccessMask =
        VK_ACCESS_MEMORY_WRITE_BIT;  // Every write must have finished...
    barrier.dstAccessMask =
        VK_ACCESS_MEMORY_READ_BIT |
        VK_ACCESS_MEMORY_WRITE_BIT;  // ... before it is safe to read or write
    // (Image Layout Transitions perform
    // both, read AND write access.)

    sourceStage = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;  // All commands must have
    // finished...
    destinationStage =
        VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;  // ...before any command may
                                             // continue. (Very heavy
                                             // barrier.)
  }

  vkCmdPipelineBarrier(commandBuffer, sourceStage, destinationStage, 0, 0,
                       nullptr, 0, nullptr, 1, &barrier);
}

void CE::Image::loadTexture(const std::string& imagePath,
                            const VkFormat format,
                            VkCommandBuffer& commandBuffer,
                            const VkCommandPool& commandPool,
                            const VkQueue& queue) {
  Log::text("{ img }", "Image Texture: ", imagePath);

  int texWidth(0), texHeight(0), texChannels(0), rgba(4);
  stbi_uc* pixels = stbi_load(imagePath.c_str(), &texWidth, &texHeight,
                              &texChannels, STBI_rgb_alpha);
  VkDeviceSize imageSize = static_cast<VkDeviceSize>(texWidth) *
                           static_cast<VkDeviceSize>(texHeight) *
                           static_cast<VkDeviceSize>(rgba);

  if (!pixels) {
    throw std::runtime_error("failed to load texture image!");
  }

  Buffer stagingResources{};

  Buffer::create(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                 VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
                     VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                 stagingResources);

  void* data{};
  vkMapMemory(Device::baseDevice->logical, stagingResources.memory, 0,
              imageSize, 0, &data);
  memcpy(data, pixels, static_cast<size_t>(imageSize));
  vkUnmapMemory(Device::baseDevice->logical, stagingResources.memory);
  stbi_image_free(pixels);

  this->create(texWidth, texHeight, VK_SAMPLE_COUNT_1_BIT, format,
               VK_IMAGE_TILING_OPTIMAL,
               VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT,
               VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);

  CommandBuffers::beginSingularCommands(commandPool, queue);
  this->transitionLayout(commandBuffer, VK_FORMAT_R8G8B8A8_SRGB,
                         VK_IMAGE_LAYOUT_UNDEFINED,
                         VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);
  CommandBuffers::endSingularCommands(commandPool, queue);

  Buffer::copyToImage(
      stagingResources.buffer, this->image, static_cast<uint32_t>(texWidth),
      static_cast<uint32_t>(texHeight), commandBuffer, commandPool, queue);

  CommandBuffers::beginSingularCommands(commandPool, queue);
  this->transitionLayout(commandBuffer, VK_FORMAT_R8G8B8A8_SRGB,
                         VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                         VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);
  CommandBuffers::endSingularCommands(commandPool, queue);
}

void CE::Image::useSwapchainImages(CE::Swapchain& swapchain,
    VkCommandBuffer& commandBuffer,
    const VkCommandPool& commandPool,
    const VkQueue& queue) {
    Log::text("{ img }", "Image Texture: Swapchain Images");

    for (size_t i = 0; i < swapchain.images.size(); ++i) {
        CE::Image& swapchainImage = swapchain.images[i];

        // Transition swapchain image layout for copying
        CommandBuffers::beginSingularCommands(commandPool, queue);
        swapchainImage.transitionLayout(commandBuffer, VK_FORMAT_R8G8B8A8_SRGB,
            VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
            VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL);
        CommandBuffers::endSingularCommands(commandPool, queue);

        // Transition current image layout for copying
        CommandBuffers::beginSingularCommands(commandPool, queue);
        this->transitionLayout(commandBuffer, VK_FORMAT_R8G8B8A8_SRGB,
            VK_IMAGE_LAYOUT_UNDEFINED,
            VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);
        CommandBuffers::endSingularCommands(commandPool, queue);

        // Copy data from swapchain image to current image
        this->copyFromSwapchainImage(swapchain, commandBuffer, commandPool, queue); // Add this function

        // Transition current image layout for shader access
        CommandBuffers::beginSingularCommands(commandPool, queue);
        this->transitionLayout(commandBuffer, VK_FORMAT_R8G8B8A8_SRGB,
            VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
            VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);
        CommandBuffers::endSingularCommands(commandPool, queue);

        // Transition swapchain image layout back to present
        CommandBuffers::beginSingularCommands(commandPool, queue);
        swapchainImage.transitionLayout(commandBuffer, VK_FORMAT_R8G8B8A8_SRGB,
            VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
            VK_IMAGE_LAYOUT_PRESENT_SRC_KHR);
        CommandBuffers::endSingularCommands(commandPool, queue);
    }
}



const VkFormat CE::Image::findDepthFormat() {
  return findSupportedFormat(
      {VK_FORMAT_D32_SFLOAT, VK_FORMAT_D32_SFLOAT_S8_UINT,
       VK_FORMAT_D24_UNORM_S8_UINT},
      VK_IMAGE_TILING_OPTIMAL, VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT);
}

const VkFormat CE::Image::findSupportedFormat(
    const std::vector<VkFormat>& candidates,
    const VkImageTiling tiling,
    const VkFormatFeatureFlags& features) {
  for (VkFormat format : candidates) {
    VkFormatProperties props{};
    vkGetPhysicalDeviceFormatProperties(Device::baseDevice->physical, format,
                                        &props);

    if (tiling == VK_IMAGE_TILING_LINEAR &&
        (props.linearTilingFeatures & features) == features) {
      return format;
    } else if (tiling == VK_IMAGE_TILING_OPTIMAL &&
               (props.optimalTilingFeatures & features) == features) {
      return format;
    }
  }
  throw std::runtime_error("\n!ERROR! failed to find supported format!");
}

void CE::Image::createResources(const VkExtent2D& dimensions,
                                const VkFormat format,
                                const VkImageUsageFlags usage,
                                const VkImageAspectFlagBits aspect) {
  Log::text("{ []< }", "Color Resources ");
  this->destroyVulkanImages();
  this->create(dimensions.width, dimensions.height,
               Device::baseDevice->maxUsableSampleCount, format,
               VK_IMAGE_TILING_OPTIMAL, usage,
               VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);
  this->createView(aspect);
}

void CE::Image::createSampler() {
  Log::text("{ img }", "Texture Sampler");
  VkPhysicalDeviceProperties properties;
  vkGetPhysicalDeviceProperties(Device::baseDevice->physical, &properties);

  VkSamplerCreateInfo samplerInfo{
      .sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
      .magFilter = VK_FILTER_LINEAR,
      .minFilter = VK_FILTER_LINEAR,
      .mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR,
      .addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT,
      .addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT,
      .addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT,
      .anisotropyEnable = VK_TRUE,
      .maxAnisotropy = properties.limits.maxSamplerAnisotropy,
      .compareEnable = VK_FALSE,
      .compareOp = VK_COMPARE_OP_ALWAYS,
      .borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK,
      .unnormalizedCoordinates = VK_FALSE};

  if (vkCreateSampler(Device::baseDevice->logical, &samplerInfo, nullptr,
                      &this->sampler) != VK_SUCCESS) {
    throw std::runtime_error("failed to create texture sampler!");
  }
}

CE::Descriptor::~Descriptor() {
  if (Device::baseDevice) {
    if (this->pool != VK_NULL_HANDLE) {
      vkDestroyDescriptorPool(Device::baseDevice->logical, this->pool, nullptr);
      this->pool = VK_NULL_HANDLE;
    };
    if (this->setLayout != VK_NULL_HANDLE) {
      vkDestroyDescriptorSetLayout(Device::baseDevice->logical, this->setLayout,
                                   nullptr);
      this->setLayout = VK_NULL_HANDLE;
    };
  }
}

void CE::Descriptor::createSetLayout(
    const std::array<VkDescriptorSetLayoutBinding, NUM_DESCRIPTORS>&
        layoutBindings) {
  Log::text("{ |=| }", "Descriptor Set Layout:", layoutBindings.size(),
            "bindings");
  for (const VkDescriptorSetLayoutBinding& item : layoutBindings) {
    Log::text("{ ", item.binding, " }",
              Log::getDescriptorTypeString(item.descriptorType));
    Log::text(Log::Style::charLeader,
              Log::getShaderStageString(item.stageFlags));
  }

  VkDescriptorSetLayoutCreateInfo layoutInfo{
      .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
      .bindingCount = static_cast<uint32_t>(layoutBindings.size()),
      .pBindings = layoutBindings.data()};

  CE::VULKAN_RESULT(vkCreateDescriptorSetLayout,
                    CE::Device::baseDevice->logical, &layoutInfo, nullptr,
                    &CE::Descriptor::setLayout);
}

void CE::Descriptor::createPool() {
  Log::text("{ |=| }", "Descriptor Pool");
  for (size_t i = 0; i < poolSizes.size(); i++) {
    Log::text(Log::Style::charLeader,
              Log::getDescriptorTypeString(poolSizes[i].type));
  }
  VkDescriptorPoolCreateInfo poolInfo{
      .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
      .maxSets = MAX_FRAMES_IN_FLIGHT,
      .poolSizeCount = static_cast<uint32_t>(poolSizes.size()),
      .pPoolSizes = poolSizes.data()};
  CE::VULKAN_RESULT(vkCreateDescriptorPool, Device::baseDevice->logical,
                    &poolInfo, nullptr, &CE::Descriptor::pool);
}

void CE::Descriptor::allocateSets() {
  std::vector<VkDescriptorSetLayout> layouts(MAX_FRAMES_IN_FLIGHT, setLayout);
  VkDescriptorSetAllocateInfo allocateInfo{
      .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
      .descriptorPool = pool,
      .descriptorSetCount = MAX_FRAMES_IN_FLIGHT,
      .pSetLayouts = layouts.data()};
  CE::VULKAN_RESULT(vkAllocateDescriptorSets, Device::baseDevice->logical,
                    &allocateInfo, sets.data());
}

void CE::Descriptor::updateSets(
    const std::array<VkDescriptorSet, MAX_FRAMES_IN_FLIGHT>& sets,
    std::array<std::array<VkWriteDescriptorSet, NUM_DESCRIPTORS>,
               MAX_FRAMES_IN_FLIGHT>& descriptorWrites) {
  Log::text("{ |=| }", "Update Descriptor Sets");

  for (uint32_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
    for (auto& descriptor : descriptorWrites[i]) {
      descriptor.dstSet = CE::Descriptor::sets[i];
    }

    vkUpdateDescriptorSets(CE::Device::baseDevice->logical,
                           static_cast<uint32_t>(descriptorWrites[i].size()),
                           descriptorWrites[i].data(), 0, nullptr);
  }
}

CE::CommandBuffers::~CommandBuffers() {
  if (Device::baseDevice && this->pool != VK_NULL_HANDLE) {
    vkDestroyCommandPool(Device::baseDevice->logical, this->pool, nullptr);
  }
};

void CE::CommandBuffers::createPool(
    const Queues::FamilyIndices& familyIndices) {
  Log::text("{ cmd }", "Command Pool");

  VkCommandPoolCreateInfo poolInfo{
      .sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
      .flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
      .queueFamilyIndex = familyIndices.graphicsAndComputeFamily.value()};

  CE::VULKAN_RESULT(vkCreateCommandPool, Device::baseDevice->logical, &poolInfo,
                    nullptr, &this->pool);
}

void CE::CommandBuffers::beginSingularCommands(const VkCommandPool& commandPool,
                                               const VkQueue& queue) {
  Log::text("{ 1.. }", "Begin Single Time Commands");

  VkCommandBufferAllocateInfo allocInfo{
      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
      .commandPool = commandPool,
      .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
      .commandBufferCount = 1};

  vkAllocateCommandBuffers(Device::baseDevice->logical, &allocInfo,
                           &singularCommandBuffer);

  VkCommandBufferBeginInfo beginInfo{
      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
      .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT};
  vkBeginCommandBuffer(singularCommandBuffer, &beginInfo);

  return;
}

void CE::CommandBuffers::endSingularCommands(const VkCommandPool& commandPool,
                                             const VkQueue& queue) {
  Log::text("{ ..1 }", "End Single Time Commands");

  vkEndCommandBuffer(singularCommandBuffer);
  VkSubmitInfo submitInfo{.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
                          .commandBufferCount = 1,
                          .pCommandBuffers = &singularCommandBuffer};

  vkQueueSubmit(queue, 1, &submitInfo, VK_NULL_HANDLE);
  vkQueueWaitIdle(queue);
  vkFreeCommandBuffers(Device::baseDevice->logical, commandPool, 1,
                       &singularCommandBuffer);
}

void CE::CommandBuffers::createBuffers(
    std::array<VkCommandBuffer, MAX_FRAMES_IN_FLIGHT>& commandBuffers) const {
  Log::text("{ cmd }", "Command Buffers:", MAX_FRAMES_IN_FLIGHT);
  VkCommandBufferAllocateInfo allocateInfo{
      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
      .commandPool = this->pool,
      .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
      .commandBufferCount = static_cast<uint32_t>(commandBuffers.size())};

  CE::VULKAN_RESULT(vkAllocateCommandBuffers, CE::Device::baseDevice->logical,
                    &allocateInfo, commandBuffers.data());
}

void CE::Device::destroyDevice() {
  static bool isDeviceDestroyed = false;
  for (const VkDevice& device : destroyedDevices) {
    if (device == this->logical) {
      isDeviceDestroyed = true;
      break;
    }
  }
  if (!isDeviceDestroyed) {
    Log::text("{ +++ }", "Destroy Device", this->logical, "@", &this->logical);
    extensions.clear();
    vkDestroyDevice(this->logical, nullptr);
    destroyedDevices.push_back(this->logical);
  }
}

const CE::Swapchain::SupportDetails CE::Swapchain::checkSupport(
    const VkPhysicalDevice& physicalDevice,
    const VkSurfaceKHR& surface) {
  Log::text(Log::Style::charLeader, "Query Swap Chain Support");
  {
    Swapchain::SupportDetails details{};
    vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface,
                                              &details.capabilities);
    uint32_t formatCount(0);
    vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, &formatCount,
                                         nullptr);
    if (formatCount != 0) {
      details.formats.resize(formatCount);
      vkGetPhysicalDeviceSurfaceFormatsKHR(
          physicalDevice, surface, &formatCount, details.formats.data());
    }
    uint32_t presentModeCount(0);
    vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface,
                                              &presentModeCount, nullptr);
    if (presentModeCount != 0) {
      details.presentModes.resize(presentModeCount);
      vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface,
                                                &presentModeCount,
                                                details.presentModes.data());
    }
    this->supportDetails = details;
    return details;
  }
}

const VkSurfaceFormatKHR CE::Swapchain::pickSurfaceFormat(
    const std::vector<VkSurfaceFormatKHR>& availableFormats) const {
  Log::text(Log::Style::charLeader, "Choose Swap Surface Format");

  for (const auto& availableFormat : availableFormats) {
    if (availableFormat.format == VK_FORMAT_R8G8B8A8_SRGB &&
        availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
      return availableFormat;
    }
  }
  return availableFormats[0];
}

const VkPresentModeKHR CE::Swapchain::pickPresentMode(
    const std::vector<VkPresentModeKHR>& availablePresentModes) const {
  Log::text(Log::Style::charLeader, "Choose Swap Present Mode");
  for (const auto& availablePresentMode : availablePresentModes) {
    if (availablePresentMode == VK_PRESENT_MODE_FIFO_KHR) {
      return availablePresentMode;
    }
  }
  return VK_PRESENT_MODE_MAILBOX_KHR;
}

const VkExtent2D CE::Swapchain::pickExtent(
    GLFWwindow* window,
    const VkSurfaceCapabilitiesKHR& capabilities) const {
  Log::text(Log::Style::charLeader, "Choose Swap Extent");

  if (capabilities.currentExtent.width !=
      std::numeric_limits<uint32_t>::max()) {
    return capabilities.currentExtent;
  } else {
    int width(0), height(0);
    glfwGetFramebufferSize(window, &width, &height);

    VkExtent2D actualExtent{static_cast<uint32_t>(width),
                            static_cast<uint32_t>(height)};
    actualExtent.width =
        std::clamp(actualExtent.width, capabilities.minImageExtent.width,
                   capabilities.maxImageExtent.width);
    actualExtent.height =
        std::clamp(actualExtent.height, capabilities.minImageExtent.height,
                   capabilities.maxImageExtent.height);

    return actualExtent;
  }
}

const uint32_t CE::Swapchain::getImageCount(
    const Swapchain::SupportDetails& swapchainSupport) const {
  uint32_t imageCount = swapchainSupport.capabilities.minImageCount;
  if (swapchainSupport.capabilities.maxImageCount > 0 &&
      imageCount > swapchainSupport.capabilities.maxImageCount) {
    imageCount = swapchainSupport.capabilities.maxImageCount;
  }
  return imageCount;
}

void CE::Swapchain::destroy() {
  if (Device::baseDevice) {
    Log::text("{ <-> }", "Destroy Swapchain");

    for (uint_fast8_t i = 0; i < this->framebuffers.size(); i++) {
      vkDestroyFramebuffer(Device::baseDevice->logical, this->framebuffers[i],
                           nullptr);
    }
    for (uint_fast8_t i = 0; i < this->images.size(); i++) {
      vkDestroyImageView(Device::baseDevice->logical, this->images[i].view,
                         nullptr);
    }
    vkDestroySwapchainKHR(Device::baseDevice->logical, this->swapchain,
                          nullptr);
  }
}

void CE::Swapchain::recreate(const VkSurfaceKHR& surface,
                             const Queues& queues,
                             SynchronizationObjects& syncObjects) {
  int width(0), height(0);
  glfwGetFramebufferSize(Window::get().window, &width, &height);
  while (width == 0 || height == 0) {
    glfwGetFramebufferSize(Window::get().window, &width, &height);
    glfwWaitEvents();
  }

  vkDeviceWaitIdle(Device::baseDevice->logical);

  destroy();
  create(surface, queues);

  uint32_t reset = 1;
  syncObjects.currentFrame = reset;
}

void CE::Swapchain::create(const VkSurfaceKHR& surface, const Queues& queues) {
  Log::text("{ <-> }", "Swap Chain");
  Swapchain::SupportDetails swapchainSupport =
      checkSupport(Device::baseDevice->physical, surface);
  VkSurfaceFormatKHR surfaceFormat =
      pickSurfaceFormat(swapchainSupport.formats);
  VkPresentModeKHR presentMode = pickPresentMode(swapchainSupport.presentModes);
  VkExtent2D extent =
      pickExtent(Window::get().window, supportDetails.capabilities);

  uint32_t imageCount = getImageCount(swapchainSupport);

  VkSwapchainCreateInfoKHR createInfo{
      .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
      .surface = surface,
      .minImageCount = imageCount,
      .imageFormat = surfaceFormat.format,
      .imageColorSpace = surfaceFormat.colorSpace,
      .imageExtent = extent,
      .imageArrayLayers = 1,
      .imageUsage =
          VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_STORAGE_BIT,
      .preTransform = swapchainSupport.capabilities.currentTransform,
      .compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,
      .presentMode = presentMode,
      .clipped = VK_TRUE};

  std::vector<uint32_t> queueFamilyIndices{
      queues.familyIndices.graphicsAndComputeFamily.value(),
      queues.familyIndices.presentFamily.value()};

  if (queues.familyIndices.graphicsAndComputeFamily !=
      queues.familyIndices.presentFamily) {
    createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;
    createInfo.queueFamilyIndexCount =
        static_cast<uint32_t>(queueFamilyIndices.size());
    createInfo.pQueueFamilyIndices = queueFamilyIndices.data();
  } else {
    createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
  }

  CE::VULKAN_RESULT(vkCreateSwapchainKHR, Device::baseDevice->logical,
                    &createInfo, nullptr, &this->swapchain);

  vkGetSwapchainImagesKHR(Device::baseDevice->logical, this->swapchain,
                          &imageCount, nullptr);

  this->imageFormat = surfaceFormat.format;
  this->extent = extent;

  std::vector<VkImage> swapchainImages(MAX_FRAMES_IN_FLIGHT);
  vkGetSwapchainImagesKHR(Device::baseDevice->logical, this->swapchain,
                          &imageCount, swapchainImages.data());

  for (uint_fast8_t i = 0; i < imageCount; i++) {
    this->images[i].image = swapchainImages[i];
    this->images[i].info.format = this->imageFormat;
    this->images[i].createView(VK_IMAGE_ASPECT_COLOR_BIT);
  };
}

const CE::Queues::FamilyIndices CE::Queues::findQueueFamilies(
    const VkPhysicalDevice& physicalDevice,
    const VkSurfaceKHR& surface) const {
  Log::text(Log::Style::charLeader, "Find Queue Families");

  CE::Queues::FamilyIndices indices{};
  uint32_t queueFamilyCount(0);
  vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &queueFamilyCount,
                                           nullptr);
  std::vector<VkQueueFamilyProperties> queueFamilies(queueFamilyCount);
  vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &queueFamilyCount,
                                           queueFamilies.data());

  int i(0);
  for (const auto& queueFamily : queueFamilies) {
    if ((queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) &&
        (queueFamily.queueFlags & VK_QUEUE_COMPUTE_BIT)) {
      indices.graphicsAndComputeFamily = i;
    }
    VkBool32 presentSupport = false;
    vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, i, surface,
                                         &presentSupport);
    if (presentSupport) {
      indices.presentFamily = i;
    }
    if (indices.isComplete()) {
      break;
    }
    i++;
  }
  return indices;
}

void CE::SynchronizationObjects::create() {
  Log::text("{ ||| }", "Sync Objects");

  VkSemaphoreCreateInfo semaphoreInfo{
      .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO};

  VkFenceCreateInfo fenceInfo{.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
                              .flags = VK_FENCE_CREATE_SIGNALED_BIT};

  for (uint_fast8_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
    CE::VULKAN_RESULT(vkCreateSemaphore, Device::baseDevice->logical,
                      &semaphoreInfo, nullptr,
                      &this->imageAvailableSemaphores[i]);
    CE::VULKAN_RESULT(vkCreateSemaphore, Device::baseDevice->logical,
                      &semaphoreInfo, nullptr,
                      &this->renderFinishedSemaphores[i]);
    CE::VULKAN_RESULT(vkCreateFence, Device::baseDevice->logical, &fenceInfo,
                      nullptr, &this->graphicsInFlightFences[i]);
    CE::VULKAN_RESULT(vkCreateSemaphore, Device::baseDevice->logical,
                      &semaphoreInfo, nullptr,
                      &this->computeFinishedSemaphores[i]);
    CE::VULKAN_RESULT(vkCreateFence, Device::baseDevice->logical, &fenceInfo,
                      nullptr, &this->computeInFlightFences[i]);
  }
}

void CE::SynchronizationObjects::destroy() const {
  if (Device::baseDevice) {
    Log::text("{ ||| }", "Destroy Synchronization Objects");
    for (uint_fast8_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
      vkDestroySemaphore(Device::baseDevice->logical,
                         this->renderFinishedSemaphores[i], nullptr);
      vkDestroySemaphore(Device::baseDevice->logical,
                         this->imageAvailableSemaphores[i], nullptr);
      vkDestroySemaphore(Device::baseDevice->logical,
                         this->computeFinishedSemaphores[i], nullptr);
      vkDestroyFence(Device::baseDevice->logical,
                     this->graphicsInFlightFences[i], nullptr);
      vkDestroyFence(Device::baseDevice->logical,
                     this->computeInFlightFences[i], nullptr);
    };
  }
}

CE::InitializeVulkan::InitializeVulkan() {
  Log::text("{ VkI }", "constructing Initialize Vulkan");
  createInstance();
  this->validation.setupDebugMessenger(this->instance);
  createSurface(Window::get().window);
}

CE::InitializeVulkan::~InitializeVulkan() {
  Log::text("{ VkI }", "destructing Initialize Vulkan");
  if (this->validation.enableValidationLayers) {
    this->validation.DestroyDebugUtilsMessengerEXT(
        this->instance, this->validation.debugMessenger, nullptr);
  }
  vkDestroySurfaceKHR(this->instance, this->surface, nullptr);
  vkDestroyInstance(this->instance, nullptr);
}

void CE::InitializeVulkan::createInstance() {
  Log::text("{ VkI }", "Vulkan Instance");
  if (this->validation.enableValidationLayers &&
      !this->validation.checkValidationLayerSupport()) {
    throw std::runtime_error(
        "\n!ERROR! validation layers requested, but not available!");
  }

  VkApplicationInfo appInfo{.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,
                            .pApplicationName = Window::get().display.title,
                            .applicationVersion = VK_MAKE_VERSION(0, 0, 1),
                            .pEngineName = "CAPITAL Engine",
                            .engineVersion = VK_MAKE_VERSION(0, 0, 1),
                            .apiVersion = VK_API_VERSION_1_3};
  Log::text(Log::Style::charLeader, appInfo.pApplicationName,
            appInfo.applicationVersion, "-", appInfo.pEngineName,
            appInfo.engineVersion, "-", "Vulkan", 1.3);

  std::vector<const char*> extensions = getRequiredExtensions();

  VkInstanceCreateInfo createInfo{
      .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
      .pNext = nullptr,
      .pApplicationInfo = &appInfo,
      .enabledLayerCount = 0,
      .enabledExtensionCount = static_cast<uint32_t>(extensions.size()),
      .ppEnabledExtensionNames = extensions.data()};

  VkDebugUtilsMessengerCreateInfoEXT debugCreateInfo{};
  if (this->validation.enableValidationLayers) {
    createInfo.enabledLayerCount =
        static_cast<uint32_t>(this->validation.validation.size());
    createInfo.ppEnabledLayerNames = this->validation.validation.data();

    this->validation.populateDebugMessengerCreateInfo(debugCreateInfo);
    createInfo.pNext = &debugCreateInfo;
  }
  CE::VULKAN_RESULT(vkCreateInstance, &createInfo, nullptr, &this->instance);
}

void CE::InitializeVulkan::createSurface(GLFWwindow* window) {
  Log::text("{ [ ] }", "Surface");
  CE::VULKAN_RESULT(glfwCreateWindowSurface, this->instance, window, nullptr,
                    &this->surface);
}

std::vector<const char*> CE::InitializeVulkan::getRequiredExtensions() const {
  uint32_t glfwExtensionCount(0);
  const char** glfwExtensions;
  glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);

  std::vector<const char*> extensions(glfwExtensions,
                                      glfwExtensions + glfwExtensionCount);
  if (this->validation.enableValidationLayers) {
    extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
  }
  return extensions;
}

CE::RenderPass::~RenderPass() {
  Log::text("{ []< }", "destructing Render Pass");
  if (Device::baseDevice) {
    vkDestroyRenderPass(Device::baseDevice->logical, this->renderPass, nullptr);
  }
}

void CE::RenderPass::create(VkSampleCountFlagBits msaaImageSamples,
                            VkFormat swapchainImageFormat) {
  Log::text("{ []< }", "Render Pass");
  Log::text(Log::Style::charLeader,
            "colorAttachment, depthAttachment, colorAttachmentResolve");

  VkAttachmentDescription colorAttachment{
      .format = swapchainImageFormat,
      .samples = msaaImageSamples,
      .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR,
      .storeOp = VK_ATTACHMENT_STORE_OP_STORE,
      .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
      .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
      .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
      .finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL};

  VkAttachmentDescription depthAttachment{
      .format = CE::Image::findDepthFormat(),
      .samples = msaaImageSamples,
      .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR,
      .storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
      .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
      .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
      .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
      .finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL};

  VkAttachmentDescription colorAttachmentResolve{
      .format = swapchainImageFormat,
      .samples = VK_SAMPLE_COUNT_1_BIT,
      .loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
      .storeOp = VK_ATTACHMENT_STORE_OP_STORE,
      .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
      .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
      .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
      .finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR};

  VkAttachmentReference colorAttachmentRef{
      .attachment = 0, .layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL};

  VkAttachmentReference depthAttachmentRef{
      .attachment = 1,
      .layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL};

  VkAttachmentReference colorAttachmentResolveRef{
      .attachment = 2, .layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL};

  VkSubpassDescription subpass{
      .pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS,
      .colorAttachmentCount = 1,
      .pColorAttachments = &colorAttachmentRef,
      .pResolveAttachments = &colorAttachmentResolveRef,
      .pDepthStencilAttachment = &depthAttachmentRef};

  VkSubpassDependency dependency{
      .srcSubpass = VK_SUBPASS_EXTERNAL,
      .dstSubpass = 0,
      .srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT |
                      VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
      .dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT |
                      VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
      .srcAccessMask = 0,
      .dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT |
                       VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT};

  std::vector<VkAttachmentDescription> attachments = {
      colorAttachment, depthAttachment, colorAttachmentResolve};

  VkRenderPassCreateInfo renderPassInfo{
      .sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
      .attachmentCount = static_cast<uint32_t>(attachments.size()),
      .pAttachments = attachments.data(),
      .subpassCount = 1,
      .pSubpasses = &subpass,
      .dependencyCount = 1,
      .pDependencies = &dependency};

  CE::VULKAN_RESULT(vkCreateRenderPass, Device::baseDevice->logical,
                    &renderPassInfo, nullptr, &this->renderPass);
}

void CE::RenderPass::createFramebuffers(CE::Swapchain& swapchain,
                                        const VkImageView& msaaView,
                                        const VkImageView& depthView) const {
  Log::text("{ 101 }", "Frame Buffers:", swapchain.images.size());

  Log::text(Log::Style::charLeader,
            "attachments: msaaImage., depthImage, swapchain imageViews");
  for (uint_fast8_t i = 0; i < swapchain.images.size(); i++) {
    std::array<VkImageView, 3> attachments{msaaView, depthView,
                                           swapchain.images[i].view};

    VkFramebufferCreateInfo framebufferInfo{
        .sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
        .renderPass = renderPass,
        .attachmentCount = static_cast<uint32_t>(attachments.size()),
        .pAttachments = attachments.data(),
        .width = swapchain.extent.width,
        .height = swapchain.extent.height,
        .layers = 1};

    CE::VULKAN_RESULT(vkCreateFramebuffer, CE::Device::baseDevice->logical,
                      &framebufferInfo, nullptr, &swapchain.framebuffers[i]);
  }
}

CE::PipelinesConfiguration::~PipelinesConfiguration() {
  if (Device::baseDevice) {
    Log::text("{ === }", "destructing", this->pipelineMap.size(),
              "Pipelines Configuration");
    for (auto& pipeline : this->pipelineMap) {
      VkPipeline& pipelineObject = getPipelineObjectByName(pipeline.first);
      vkDestroyPipeline(Device::baseDevice->logical, pipelineObject, nullptr);
    }
  }
}

void CE::PipelinesConfiguration::createPipelines(
    VkRenderPass& renderPass,
    const VkPipelineLayout& graphicsLayout,
    const VkPipelineLayout& computeLayout,
    VkSampleCountFlagBits& msaaSamples) {
  for (auto& entry : this->pipelineMap) {
    const std::string pipelineName = entry.first;

    std::vector<std::string> shaders = getPipelineShadersByName(pipelineName);
    bool isCompute =
        std::find(shaders.begin(), shaders.end(), "Comp") != shaders.end();

    if (!isCompute) [[likely]] {
      Log::text("{ === }", "Graphics Pipeline: ", pipelineName);
      std::variant<Graphics, Compute>& pipelineVariant =
          this->pipelineMap[pipelineName];

      std::vector<VkPipelineShaderStageCreateInfo> shaderStages{};
      bool tesselationEnabled = setShaderStages(pipelineName, shaderStages);

      const auto& bindingDescription =
          std::get<CE::PipelinesConfiguration::Graphics>(pipelineVariant)
              .vertexBindings;
      const auto& attributesDescription =
          std::get<CE::PipelinesConfiguration::Graphics>(pipelineVariant)
              .vertexAttributes;
      uint32_t bindingsSize = static_cast<uint32_t>(bindingDescription.size());
      uint32_t attributeSize =
          static_cast<uint32_t>(attributesDescription.size());

      for (const auto& item : bindingDescription) {
        Log::text(Log::Style::charLeader, "binding:", item.binding,
                  item.inputRate ? "VK_VERTEX_INPUT_RATE_INSTANCE"
                                 : "VK_VERTEX_INPUT_RATE_VERTEX");
      }

      VkPipelineVertexInputStateCreateInfo vertexInput{
          CE::vertexInputStateDefault};
      vertexInput.vertexBindingDescriptionCount = bindingsSize;
      vertexInput.vertexAttributeDescriptionCount = attributeSize;
      vertexInput.pVertexBindingDescriptions = bindingDescription.data();
      vertexInput.pVertexAttributeDescriptions = attributesDescription.data();

      VkPipelineInputAssemblyStateCreateInfo inputAssembly{
          CE::inputAssemblyStateTriangleList};

      VkPipelineRasterizationStateCreateInfo rasterization{
          CE::rasterizationCullBackBit};

      VkPipelineMultisampleStateCreateInfo multisampling{
          CE::multisampleStateDefault};
      multisampling.rasterizationSamples = msaaSamples;
      VkPipelineDepthStencilStateCreateInfo depthStencil{
          CE::depthStencilStateDefault};

      static VkPipelineColorBlendAttachmentState colorBlendAttachment{
          CE::colorBlendAttachmentStateFalse};
      VkPipelineColorBlendStateCreateInfo colorBlend{
          CE::colorBlendStateDefault};
      colorBlend.pAttachments = &colorBlendAttachment;

      VkPipelineViewportStateCreateInfo viewport{CE::viewportStateDefault};
      VkPipelineDynamicStateCreateInfo dynamic{CE::dynamicStateDefault};

      VkGraphicsPipelineCreateInfo pipelineInfo{
          .sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
          .stageCount = static_cast<uint32_t>(shaderStages.size()),
          .pStages = shaderStages.data(),
          .pVertexInputState = &vertexInput,
          .pInputAssemblyState = &inputAssembly,
          .pViewportState = &viewport,
          .pRasterizationState = &rasterization,
          .pMultisampleState = &multisampling,
          .pDepthStencilState = &depthStencil,
          .pColorBlendState = &colorBlend,
          .pDynamicState = &dynamic,
          .layout = graphicsLayout,
          .renderPass = renderPass,
          .subpass = 0,
          .basePipelineHandle = VK_NULL_HANDLE};

      VkPipelineTessellationStateCreateInfo tessellationStateInfo{
          CE::tessellationStateDefault};
      if (tesselationEnabled) {
        inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_PATCH_LIST;
        rasterization.polygonMode = VK_POLYGON_MODE_LINE;
        rasterization.lineWidth = 5.0f;
        colorBlendAttachment = CE::colorBlendAttachmentStateMultiply;
        pipelineInfo.pTessellationState = &tessellationStateInfo;
      }

      CE::VULKAN_RESULT(vkCreateGraphicsPipelines, Device::baseDevice->logical,
                        VK_NULL_HANDLE, 1, &pipelineInfo, nullptr,
                        &getPipelineObjectByName(pipelineName));
      destroyShaderModules();
    } else if (isCompute) {
      Log::text("{ === }", "Compute  Pipeline: ", pipelineName);

      VkPipelineShaderStageCreateInfo shaderStage{createShaderModules(
          VK_SHADER_STAGE_COMPUTE_BIT, pipelineName + shaders[0] + ".spv")};

      VkComputePipelineCreateInfo pipelineInfo{
          .sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
          .stage = shaderStage,
          .layout = computeLayout};

      CE::VULKAN_RESULT(vkCreateComputePipelines, Device::baseDevice->logical,
                        VK_NULL_HANDLE, 1, &pipelineInfo, nullptr,
                        &getPipelineObjectByName(pipelineName));
      destroyShaderModules();
    }
  }
}

bool CE::PipelinesConfiguration::setShaderStages(
    const std::string& pipelineName,
    std::vector<VkPipelineShaderStageCreateInfo>& shaderStages) {
  std::vector<std::string> shaders = getPipelineShadersByName(pipelineName);
  std::string shaderName{};
  const std::array<std::string_view, 5> possibleStages = {"Vert", "Tesc",
                                                          "Tese", "Frag"};
  const std::unordered_map<std::string_view, VkShaderStageFlagBits> shaderType =
      {{"Vert", VK_SHADER_STAGE_VERTEX_BIT},
       {"Tesc", VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT},
       {"Tese", VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT},
       {"Frag", VK_SHADER_STAGE_FRAGMENT_BIT}};
  bool tesselationEnabled{false};

  for (uint32_t i = 0; i < shaders.size(); i++) {
    VkShaderStageFlagBits shaderStage{};

    if (shaderType.find(shaders[i]) != shaderType.end()) {
      shaderName = pipelineName + shaders[i];
      shaderStage = shaderType.at(shaders[i]);
    } else {
      shaderName = shaders[i];

      for (const std::string_view& stage : possibleStages) {
        size_t foundPosition = shaderName.find(stage);
        if (foundPosition != std::string_view::npos) {
          shaderStage = shaderType.at(stage);
          break;
        }
      }
    }
    if (!tesselationEnabled) {
      tesselationEnabled =
          shaderStage == VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT ? true
                                                                  : false;
    }
    shaderStages.push_back(
        createShaderModules(shaderStage, shaderName + ".spv"));
  }
  return tesselationEnabled;
}

std::vector<char> CE::PipelinesConfiguration::readShaderFile(
    const std::string& filename) {
  std::ifstream file(filename, std::ios::ate | std::ios::binary);

  if (!file.is_open()) {
    throw std::runtime_error("\n!ERROR! failed to open file!");
  }

  size_t fileSize = static_cast<size_t>(file.tellg());
  std::vector<char> buffer(fileSize);

  file.seekg(0);
  file.read(buffer.data(), fileSize);
  file.close();

  return buffer;
}

VkPipelineShaderStageCreateInfo CE::PipelinesConfiguration::createShaderModules(
    VkShaderStageFlagBits shaderStage,
    std::string shaderName) {
  Log::text(Log::Style::charLeader, "Shader Module", shaderName);

  std::string shaderPath = this->shaderDir + shaderName;
  auto shaderCode = readShaderFile(shaderPath);
  VkShaderModule shaderModule{VK_NULL_HANDLE};

  VkShaderModuleCreateInfo createInfo{
      .sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
      .codeSize = shaderCode.size(),
      .pCode = reinterpret_cast<const uint32_t*>(shaderCode.data())};

  CE::VULKAN_RESULT(vkCreateShaderModule, Device::baseDevice->logical,
                    &createInfo, nullptr, &shaderModule);

  shaderModules.push_back(shaderModule);

  VkPipelineShaderStageCreateInfo shaderStageInfo{
      .sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
      .stage = shaderStage,
      .module = shaderModule,
      .pName = "main"};

  return shaderStageInfo;
}

void CE::PipelinesConfiguration::compileShaders() {
  Log::text("{ GLSL }", "Compile Shaders");
  std::string systemCommand{};
  std::string shaderExtension{};
  std::string pipelineName{};

  for (const auto& entry : this->pipelineMap) {
    pipelineName = entry.first;
    std::vector<std::string> shaders = getPipelineShadersByName(pipelineName);
    for (const auto& shader : shaders) {
      if (shader == "Comp" || shader == "Vert" || shader == "Tesc" ||
          shader == "Tese" || shader == "Frag") {
        shaderExtension = Lib::upperToLowerCase(shader);
        systemCommand = Lib::path(this->shaderDir + pipelineName + "." +
                                  shaderExtension + " -o " + this->shaderDir +
                                  pipelineName + shader + ".spv");
        system(systemCommand.c_str());
      }
    }
  }
}

VkPipeline& CE::PipelinesConfiguration::getPipelineObjectByName(
    const std::string& name) {
  std::variant<Graphics, Compute>& variant = this->pipelineMap[name];
  if (std::holds_alternative<Graphics>(variant)) {
    return std::get<Graphics>(variant).pipeline;
  } else {
    return std::get<Compute>(variant).pipeline;
  }
}

void CE::PipelinesConfiguration::destroyShaderModules() {
  for (uint_fast8_t i = 0; i < this->shaderModules.size(); i++) {
    vkDestroyShaderModule(Device::baseDevice->logical, this->shaderModules[i],
                          nullptr);
  }
  this->shaderModules.resize(0);
}

const std::vector<std::string>&
CE::PipelinesConfiguration::getPipelineShadersByName(const std::string& name) {
  std::variant<Graphics, Compute>& variant = this->pipelineMap[name];

  if (std::holds_alternative<Graphics>(variant)) {
    return std::get<Graphics>(variant).shaders;
  } else {
    return std::get<Compute>(variant).shaders;
  }
}

const std::array<uint32_t, 3>& CE::PipelinesConfiguration::getWorkGroupsByName(
    const std::string& name) {
  std::variant<Graphics, Compute>& variant = this->pipelineMap[name];
  return std::get<CE::PipelinesConfiguration::Compute>(variant).workGroups;
};

void CE::PipelineLayout::createLayout(const VkDescriptorSetLayout& setLayout) {
  VkPipelineLayoutCreateInfo layout{CE::layoutDefault};
  layout.pSetLayouts = &setLayout;
  CE::VULKAN_RESULT(vkCreatePipelineLayout, Device::baseDevice->logical,
                    &layout, nullptr, &this->layout);
}

void CE::PipelineLayout::createLayout(const VkDescriptorSetLayout& setLayout,
                                      const PushConstants& _pushConstants) {
  VkPushConstantRange constants{.stageFlags = _pushConstants.shaderStage,
                                .offset = _pushConstants.offset,
                                .size = _pushConstants.size};
  VkPipelineLayoutCreateInfo layout{CE::layoutDefault};
  layout.pSetLayouts = &setLayout;
  layout.pushConstantRangeCount = _pushConstants.count;
  layout.pPushConstantRanges = &constants;
  CE::VULKAN_RESULT(vkCreatePipelineLayout, Device::baseDevice->logical,
                    &layout, nullptr, &this->layout);
}

CE::PipelineLayout::~PipelineLayout() {
  if (Device::baseDevice) {
    vkDestroyPipelineLayout(Device::baseDevice->logical, this->layout, nullptr);
  }
}

void CE::PushConstants::setData(const uint64_t& data) {
  this->data = {data};
}

#include "CapitalEngine.h"

CapitalEngine::CapitalEngine()
    : pipelines(mechanics, resources), resources(mechanics, pipelines) {
  Log::text(Log::Style::headerGuard);
  Log::text("| CAPITAL Engine");
}

CapitalEngine::~CapitalEngine() {
  Log::text(Log::Style::headerGuard);
  Log::text("| CAPITAL Engine");
  Log::text(Log::Style::headerGuard);

  glfwDestroyWindow(Window::get().window);
  glfwTerminate();
}

void CapitalEngine::mainLoop() {
  Log::text(Log::Style::headerGuard);
  Log::text("{ Main Loop }");
  Log::measureElapsedTime();

  while (!glfwWindowShouldClose(Window::get().window)) {
    glfwPollEvents();

    Window::get().setMouse();
    resources.world.time.run();

    vkDeviceWaitIdle(mechanics.mainDevice.logical);
    drawFrame();

    if (glfwGetKey(Window::get().window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {
      break;
    }
  }
  vkDeviceWaitIdle(mechanics.mainDevice.logical);

  Log::measureElapsedTime();
  Log::text("{ Main Loop }");
  Log::text(Log::Style::headerGuard);
}

void CapitalEngine::drawFrame() {
  // Compute submission
  vkWaitForFences(
      mechanics.mainDevice.logical, 1,
      &mechanics.syncObjects
           .computeInFlightFences[mechanics.syncObjects.currentFrame],
      VK_TRUE, UINT64_MAX);

  resources.uniform.update(resources.world, mechanics.swapchain.extent);

  vkResetFences(
      mechanics.mainDevice.logical, 1,
      &mechanics.syncObjects
           .computeInFlightFences[mechanics.syncObjects.currentFrame]);

  vkResetCommandBuffer(
      resources.commands.compute[mechanics.syncObjects.currentFrame], 0);
  resources.commands.recordComputeCommandBuffer(
      resources, pipelines, mechanics.syncObjects.currentFrame);

  VkSubmitInfo computeSubmitInfo{
      .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
      .commandBufferCount = 1,
      .pCommandBuffers =
          &resources.commands.compute[mechanics.syncObjects.currentFrame],
      .signalSemaphoreCount = 1,
      .pSignalSemaphores =
          &mechanics.syncObjects
               .computeFinishedSemaphores[mechanics.syncObjects.currentFrame]};

  CE::VULKAN_RESULT(
      vkQueueSubmit, mechanics.queues.compute, 1, &computeSubmitInfo,
      mechanics.syncObjects
          .computeInFlightFences[mechanics.syncObjects.currentFrame]);

  // Graphics submission
  vkWaitForFences(
      mechanics.mainDevice.logical, 1,
      &mechanics.syncObjects
           .graphicsInFlightFences[mechanics.syncObjects.currentFrame],
      VK_TRUE, UINT64_MAX);

  uint32_t imageIndex;
  VkResult result = vkAcquireNextImageKHR(
      mechanics.mainDevice.logical, mechanics.swapchain.swapchain, UINT64_MAX,
      mechanics.syncObjects
          .imageAvailableSemaphores[mechanics.syncObjects.currentFrame],
      VK_NULL_HANDLE, &imageIndex);

  if (result == VK_ERROR_OUT_OF_DATE_KHR) {
    mechanics.swapchain.recreate(mechanics.initVulkan.surface, mechanics.queues,
                                 mechanics.syncObjects, pipelines, resources);
    return;
  } else if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR) {
    throw std::runtime_error("\n!ERROR! failed to acquire swap chain image!");
  }

  vkResetFences(
      mechanics.mainDevice.logical, 1,
      &mechanics.syncObjects
           .graphicsInFlightFences[mechanics.syncObjects.currentFrame]);

  vkResetCommandBuffer(
      resources.commands.graphics[mechanics.syncObjects.currentFrame], 0);

  resources.commands.recordGraphicsCommandBuffer(
      mechanics.swapchain, resources, pipelines,
      mechanics.syncObjects.currentFrame);

  std::vector<VkSemaphore> waitSemaphores{
      mechanics.syncObjects
          .computeFinishedSemaphores[mechanics.syncObjects.currentFrame],
      mechanics.syncObjects
          .imageAvailableSemaphores[mechanics.syncObjects.currentFrame]};
  std::vector<VkPipelineStageFlags> waitStages{
      VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
      VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};

  VkSubmitInfo graphicsSubmitInfo{
      .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
      .waitSemaphoreCount = static_cast<uint32_t>(waitSemaphores.size()),
      .pWaitSemaphores = waitSemaphores.data(),
      .pWaitDstStageMask = waitStages.data(),
      .commandBufferCount = 1,
      .pCommandBuffers =
          &resources.commands.graphics[mechanics.syncObjects.currentFrame],
      .signalSemaphoreCount = 1,
      .pSignalSemaphores =
          &mechanics.syncObjects
               .renderFinishedSemaphores[mechanics.syncObjects.currentFrame]};

  CE::VULKAN_RESULT(
      vkQueueSubmit, mechanics.queues.graphics, 1, &graphicsSubmitInfo,
      mechanics.syncObjects
          .graphicsInFlightFences[mechanics.syncObjects.currentFrame]);

  std::vector<VkSwapchainKHR> swapchains{mechanics.swapchain.swapchain};

  VkPresentInfoKHR presentInfo{
      .sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
      .waitSemaphoreCount = 1,
      .pWaitSemaphores =
          &mechanics.syncObjects
               .renderFinishedSemaphores[mechanics.syncObjects.currentFrame],
      .swapchainCount = 1,
      .pSwapchains = swapchains.data(),
      .pImageIndices = &imageIndex};

  result = vkQueuePresentKHR(mechanics.queues.present, &presentInfo);

  if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR ||
      Window::get().framebufferResized) {
    Window::get().framebufferResized = false;
    mechanics.swapchain.recreate(mechanics.initVulkan.surface, mechanics.queues,
                                 mechanics.syncObjects, pipelines, resources);
  } else if (result != VK_SUCCESS) {
    throw std::runtime_error("\n!ERROR! failed to present swap chain image!");
  }

  mechanics.syncObjects.currentFrame =
      (mechanics.syncObjects.currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
}

#define TINYOBJLOADER_IMPLEMENTATION
#include <tiny_obj_loader.h>

#include "Geometry.h"
#include "Library.h"

std::vector<VkVertexInputBindingDescription> Vertex::getBindingDescription() {
  std::vector<VkVertexInputBindingDescription> binding{
      {0, sizeof(Vertex), VK_VERTEX_INPUT_RATE_VERTEX}};
  return binding;
}

std::vector<VkVertexInputAttributeDescription>
Vertex::getAttributeDescription() {
  std::vector<VkVertexInputAttributeDescription> attributes{
      {0, 0, VK_FORMAT_R32G32B32_SFLOAT,
       static_cast<uint32_t>(offsetof(Vertex, vertexPosition))},
      {1, 0, VK_FORMAT_R32G32B32_SFLOAT,
       static_cast<uint32_t>(offsetof(Vertex, color))},
      {2, 0, VK_FORMAT_R32G32_SFLOAT,
       static_cast<uint32_t>(offsetof(Vertex, textureCoordinates))}};
  return attributes;
}

template <>
struct std::hash<Vertex> {
  size_t operator()(const Vertex& vertex) const {
    return ((std::hash<glm::vec3>()(vertex.instancePosition) ^
             (std::hash<glm::vec3>()(vertex.vertexPosition) << 1) ^
             (std::hash<glm::vec3>()(vertex.normal) << 2) ^
             (std::hash<glm::vec3>()(vertex.color) << 3) ^
             (std::hash<glm::vec2>()(vertex.textureCoordinates) << 4)));
  }
};

Geometry::Geometry(const std::string& modelName) {
  if (!modelName.empty()) {
    loadModel(modelName, *this);
    transformModel(allVertices, ORIENTATION_ORDER{ROTATE_SCALE_TRANSLATE},
                   glm::vec3(90.0f, 180.0f, 0.0f));
    transformModel(uniqueVertices, ORIENTATION_ORDER{ROTATE_SCALE_TRANSLATE},
                   glm::vec3(90.0f, 180.0f, 0.0f));
  }
}

void Geometry::addVertexPosition(const glm::vec3& position) {
  uniqueVertices.push_back({glm::vec3(0.0f), position});
}

std::vector<uint32_t> Geometry::createGridPolygons(
    const std::vector<uint32_t>& vertices,
    uint32_t gridWidth) {
  std::vector<uint32_t> result;

  uint32_t numRows = static_cast<uint32_t>(vertices.size()) / gridWidth;

  for (uint32_t row = 0; row < numRows - 1; row++) {
    for (uint32_t col = 0; col < gridWidth - 1; col++) {
      // Calculate vertices for the four vertices of the quad
      uint32_t topLeft = row * gridWidth + col;
      uint32_t topRight = topLeft + 1;
      uint32_t bottomLeft = (row + 1) * gridWidth + col;
      uint32_t bottomRight = bottomLeft + 1;

      // Create the first triangle of the quad
      result.push_back(topLeft);
      result.push_back(topRight);
      result.push_back(bottomLeft);

      // Create the second triangle of the quad
      result.push_back(topRight);
      result.push_back(bottomRight);
      result.push_back(bottomLeft);
    }
  }

  return result;
}

void Geometry::createVertexBuffer(VkCommandBuffer& commandBuffer,
                                  const VkCommandPool& commandPool,
                                  const VkQueue& queue,
                                  const std::vector<Vertex>& vertices) {
  CE::Buffer stagingResources;
  VkDeviceSize bufferSize = sizeof(vertices[0]) * vertices.size();

  CE::Buffer::create(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                     VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
                         VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                     stagingResources);

  void* data;
  vkMapMemory(CE::Device::baseDevice->logical, stagingResources.memory, 0,
              bufferSize, 0, &data);
  memcpy(data, vertices.data(), (size_t)bufferSize);
  vkUnmapMemory(CE::Device::baseDevice->logical, stagingResources.memory);

  CE::Buffer::create(
      bufferSize,
      VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
      VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, this->vertexBuffer);

  CE::Buffer::copy(stagingResources.buffer, this->vertexBuffer.buffer,
                   bufferSize, commandBuffer, commandPool, queue);
}

void Geometry::createIndexBuffer(VkCommandBuffer& commandBuffer,
                                 const VkCommandPool& commandPool,
                                 const VkQueue& queue,
                                 const std::vector<uint32_t>& indices) {
  CE::Buffer stagingResources;
  VkDeviceSize bufferSize = sizeof(indices[0]) * indices.size();

  CE::Buffer::create(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                     VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
                         VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                     stagingResources);

  void* data;
  vkMapMemory(CE::Device::baseDevice->logical, stagingResources.memory, 0,
              bufferSize, 0, &data);
  memcpy(data, indices.data(), (size_t)bufferSize);
  vkUnmapMemory(CE::Device::baseDevice->logical, stagingResources.memory);

  CE::Buffer::create(
      bufferSize,
      VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
      VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, this->indexBuffer);

  CE::Buffer::copy(stagingResources.buffer, this->indexBuffer.buffer,
                   bufferSize, commandBuffer, commandPool, queue);
}

void Geometry::loadModel(const std::string& modelName, Geometry& geometry) {
  std::string baseDir = Lib::path("assets/3D/");
  std::string modelPath = baseDir + modelName + ".obj";

  tinyobj::attrib_t attrib;
  std::vector<tinyobj::shape_t> shapes;
  std::vector<tinyobj::material_t> materials;
  std::string warn, err;

  if (!tinyobj::LoadObj(&attrib, &shapes, &materials, &warn, &err,
                        modelPath.c_str(), baseDir.c_str())) {
    throw std::runtime_error(warn + err);
  }
  if (!warn.empty()) {
    std::cout << "WARN: " << warn << '\n';
  }
  if (!err.empty()) {
    std::cerr << err << '\n';
    return;
  }

  std::unordered_map<Vertex, uint32_t> tempUniqueVertices;

  for (const auto& shape : shapes) {
    for (const auto& index : shape.mesh.indices) {
      Vertex vertex{};

      vertex.vertexPosition = {attrib.vertices[3 * index.vertex_index + 0],
                               attrib.vertices[3 * index.vertex_index + 1],
                               attrib.vertices[3 * index.vertex_index + 2]};

      vertex.normal = {attrib.normals[3 * index.normal_index + 0],
                       attrib.normals[3 * index.normal_index + 1],
                       attrib.normals[3 * index.normal_index + 2]};

      vertex.textureCoordinates = {
          attrib.texcoords[2 * index.texcoord_index + 0],
          1.0f - attrib.texcoords[2 * index.texcoord_index + 1]};

      vertex.color = {1.0f, 1.0f, 1.0f};

      if (tempUniqueVertices.count(vertex) == 0) {
        tempUniqueVertices[vertex] =
            static_cast<uint32_t>(geometry.uniqueVertices.size());
        geometry.uniqueVertices.push_back(vertex);
      }
      geometry.allVertices.push_back(vertex);
      geometry.indices.push_back(tempUniqueVertices[vertex]);
    }
  }
}

void Geometry::transformModel(std::vector<Vertex>& vertices,
                              ORIENTATION_ORDER order,
                              const glm::vec3& degrees,
                              const glm::vec3& translationDistance,
                              float scale) {
  float angleX = glm::radians(degrees.x);
  float angleY = glm::radians(degrees.y);
  float angleZ = glm::radians(degrees.z);

  glm::mat4 rotationMatrix =
      glm::rotate(glm::mat4(1.0f), angleX, glm::vec3(1.0f, 0.0f, 0.0f)) *
      glm::rotate(glm::mat4(1.0f), angleY, glm::vec3(0.0f, 1.0f, 0.0f)) *
      glm::rotate(glm::mat4(1.0f), angleZ, glm::vec3(0.0f, 0.0f, 1.0f));

  for (auto& vertex : vertices) {
    switch (order) {
      case ORIENTATION_ORDER::ROTATE_SCALE_TRANSLATE:
        vertex.vertexPosition =
            glm::vec3(rotationMatrix * glm::vec4(vertex.vertexPosition, 1.0f));
        vertex.vertexPosition *= scale;
        vertex.vertexPosition = vertex.vertexPosition + translationDistance;

        vertex.normal =
            glm::vec3(rotationMatrix * glm::vec4(vertex.normal, 1.0f));
        break;
      case ORIENTATION_ORDER::ROTATE_TRANSLATE_SCALE:
        vertex.vertexPosition =
            glm::vec3(rotationMatrix * glm::vec4(vertex.vertexPosition, 1.0f));
        vertex.vertexPosition = vertex.vertexPosition + translationDistance;
        vertex.vertexPosition *= scale;

        vertex.normal =
            glm::vec3(rotationMatrix * glm::vec4(vertex.normal, 1.0f));
        break;
    }
  }
  return;
}

#include <glm/glm.hpp>

#include "Library.h"

#include <chrono>
#include <numbers>
#include <random>

std::vector<float> Lib::generateRandomValues(int amount, float min, float max) {
  std::random_device rd;
  std::mt19937 gen(rd());
  std::uniform_real_distribution<float> dis(min, max);
  std::vector<float> randomValues(amount);
  for (size_t i = 0; i < amount; ++i) {
    randomValues[i] = dis(gen);
  }
  return randomValues;
}

double Lib::lowFrequencyOscillator(double frequency) {
  using namespace std::chrono;
  static const auto start_time = high_resolution_clock::now();
  const auto time_elapsed =
      duration_cast<milliseconds>(high_resolution_clock::now() - start_time)
          .count();
  const double period = 1000.0 / frequency;
  const double angle = time_elapsed * frequency * 2 * std::numbers::pi / 1000.0;
  return 0.5 * (1 + std::sin(angle));
}

glm::vec2 Lib::smoothstep(const glm::vec2& xy) {
  constexpr float startInput = 0.0f;
  constexpr float endInput = 1.0f;
  constexpr float minIncrease = -0.1f;
  constexpr float maxIncrease = 0.1f;

  float tX = (xy.x - startInput) / (endInput - startInput);
  float tY = (xy.y - startInput) / (endInput - startInput);

  float smoothX = tX * tX * (3.0f - 2.0f * tX);
  float smoothY = tY * tY * (3.0f - 2.0f * tY);

  glm::vec2 increase = glm::mix(glm::vec2(minIncrease), glm::vec2(maxIncrease),
                                glm::vec2(smoothX, smoothY));
  return increase;
}

std::string Lib::upperToLowerCase(std::string string) {
  std::string lowerCaseString = "";
  for (char c : string) {
    if (std::isupper(c)) {
      c = std::tolower(c);
    }
    lowerCaseString += c;
  }
  return lowerCaseString;
}

std::string Lib::path(const std::string& linuxPath) {
#ifdef _WIN32
  std::string convertedWindowsPath = "..\\" + linuxPath;
  for (char& c : convertedWindowsPath) {
    if (c == '/') {
      c = '\\';
    }
  }
  if (convertedWindowsPath.substr(0, 3) == "..\\.") {
    convertedWindowsPath = convertedWindowsPath.substr(3);
  }
  return ifShaderCompile(convertedWindowsPath);
#else
  return ifShaderCompile(linuxPath);
#endif
}

std::string Lib::ifShaderCompile(std::string shaderPath) {
  if (shaderPath.find("shaders") == std::string::npos) {
    return shaderPath;
  } else {
#ifdef _WIN32
    std::string glslangValidator = "glslangValidator.exe -V ";
#else
    std::string glslangValidator = "glslc ";
#endif
    shaderPath.insert(0, glslangValidator);
    return shaderPath;
  }
}

#include "Log.h"
#include "BaseClasses.h"

#include <chrono>
#include <filesystem>
#include <string>

std::ofstream Log::logFile("log.txt");

std::string Log::Style::charLeader = std::string(8, ' ') + ": ";
std::string Log::Style::indentSize = std::string(17, ' ');
std::string Log::Style::headerGuard = std::string(
    "+-------------------------------------------------------------------------"
    "----+");
int Log::Style::columnCount = 14;
int Log::Style::columnCountOffset = 4;

std::string Log::previousTime;

void Log::measureElapsedTime() {
  static std::chrono::high_resolution_clock::time_point lastCall;
  static bool firstCall = true;

  std::chrono::high_resolution_clock::time_point now =
      std::chrono::high_resolution_clock::now();

  if (firstCall) {
    firstCall = false;
    lastCall = now;
    Log::text("{ TIME START }", "0.0", "seconds");
  } else {
    double elapsedTime =
        std::chrono::duration_cast<std::chrono::duration<double>>(now -
                                                                  lastCall)
            .count();
    Log::text("{ TIME INTERVAL }", elapsedTime, "seconds");
    lastCall = now;
  }
}

void Log::logTitle() {
  Log::text(Log::Style::headerGuard);
  Log::text("                 . - < < { ", "G E N E R A T I O N S",
            " } > > - .");
  Log::text(Log::Style::headerGuard);
  Log::measureElapsedTime();

  Log::text("{ dir }", std::filesystem::current_path().string());
}

void Log::logFooter() {
  Log::measureElapsedTime();
  Log::text(Log::Style::headerGuard);
  Log::text(" Jakob Povel | Correlate Visuals ");
}

bool Log::skipLogging(uint8_t logLevel, std::string icon) {
  if (!logFile.is_open()) {
    std::cerr << "\n!ERROR! Could not open logFile for writing" << '\n';
    return false;
  }
  if (logLevel == LOG_OFF ||
      (logLevel == LOG_MINIMIAL && (icon == std::string("{ ... }") ||
                                    icon == std::string(Style::charLeader))) ||
      (logLevel == LOG_MODERATE && icon == std::string(Style::charLeader))) {
    return true;
  }
  return false;
}

std::string Log::getBufferUsageString(const VkBufferUsageFlags& usage) {
  std::string result;

  if (usage & VK_BUFFER_USAGE_TRANSFER_SRC_BIT) {
    result += "TRANSFER_SRC | ";
  }
  if (usage & VK_BUFFER_USAGE_TRANSFER_DST_BIT) {
    result += "TRANSFER_DST | ";
  }
  if (usage & VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT) {
    result += "UNIFORM_TEXEL_BUFFER | ";
  }
  if (usage & VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT) {
    result += "STORAGE_TEXEL_BUFFER | ";
  }
  if (usage & VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT) {
    result += "UNIFORM_BUFFER | ";
  }
  if (usage & VK_BUFFER_USAGE_STORAGE_BUFFER_BIT) {
    result += "STORAGE_BUFFER | ";
  }
  if (usage & VK_BUFFER_USAGE_INDEX_BUFFER_BIT) {
    result += "INDEX_BUFFER | ";
  }
  if (usage & VK_BUFFER_USAGE_VERTEX_BUFFER_BIT) {
    result += "VERTEX_BUFFER | ";
  }
  if (usage & VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT) {
    result += "INDIRECT_BUFFER | ";
  }

  // Remove the trailing " | " if there is one.
  if (!result.empty()) {
    result.erase(result.length() - 3);
  }

  return result;
}

std::string Log::getMemoryPropertyString(
    const VkMemoryPropertyFlags& properties) {
  std::string result = "VkMemoryPropertyFlags: ";
#define ADD_FLAG_CASE(flag)                \
  if (properties & flag) {                 \
    result += STRINGIFICATION(flag) " | "; \
  }

  ADD_FLAG_CASE(VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);
  ADD_FLAG_CASE(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);
  ADD_FLAG_CASE(VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);
  ADD_FLAG_CASE(VK_MEMORY_PROPERTY_HOST_CACHED_BIT);
  ADD_FLAG_CASE(VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT);
  ADD_FLAG_CASE(VK_MEMORY_PROPERTY_PROTECTED_BIT);
  ADD_FLAG_CASE(VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD);
  ADD_FLAG_CASE(VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD);
  ADD_FLAG_CASE(VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV);

  if (!result.empty()) {
    result.erase(result.length() - 3);
  }

#undef ADD_FLAG_CASE
  return result;
}

std::string Log::getDescriptorTypeString(const VkDescriptorType& type) {
  switch (type) {
    case VK_DESCRIPTOR_TYPE_SAMPLER:
      return "VK_DESCRIPTOR_TYPE_SAMPLER";
    case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER:
      return "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER";
    case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
      return "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE";
    case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:
      return "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE";
    case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER:
      return "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER";
    case VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
      return "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER";
    case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER:
      return "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER";
    case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER:
      return "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER";
    case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC:
      return "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC";
    case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
      return "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC";
    case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
      return "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT";
    case VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK:
      return "VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK";
    case VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR:
      return "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR";
    case VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV:
      return "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV";
    case VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM:
      return "VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM";
    case VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM:
      return "VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM";
    case VK_DESCRIPTOR_TYPE_MUTABLE_EXT:
      return "VK_DESCRIPTOR_TYPE_MUTABLE_EXT";
    default:
      return "Unknown VkDescriptorType";
  }
}

std::string Log::getShaderStageString(const VkShaderStageFlags& flags) {
  std::string result = "VkShaderStageFlags: ";
#define ADD_FLAG_CASE(flag)                \
  if (flags & flag) {                      \
    result += STRINGIFICATION(flag) " | "; \
  }

  ADD_FLAG_CASE(VK_SHADER_STAGE_VERTEX_BIT);
  ADD_FLAG_CASE(VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT);
  ADD_FLAG_CASE(VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT);
  ADD_FLAG_CASE(VK_SHADER_STAGE_GEOMETRY_BIT);
  ADD_FLAG_CASE(VK_SHADER_STAGE_FRAGMENT_BIT);
  ADD_FLAG_CASE(VK_SHADER_STAGE_COMPUTE_BIT);
  ADD_FLAG_CASE(VK_SHADER_STAGE_RAYGEN_BIT_KHR);
  ADD_FLAG_CASE(VK_SHADER_STAGE_ANY_HIT_BIT_KHR);
  ADD_FLAG_CASE(VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR);
  ADD_FLAG_CASE(VK_SHADER_STAGE_MISS_BIT_KHR);
  ADD_FLAG_CASE(VK_SHADER_STAGE_INTERSECTION_BIT_KHR);
  ADD_FLAG_CASE(VK_SHADER_STAGE_CALLABLE_BIT_KHR);
  ADD_FLAG_CASE(VK_SHADER_STAGE_TASK_BIT_EXT);
  ADD_FLAG_CASE(VK_SHADER_STAGE_MESH_BIT_EXT);
  ADD_FLAG_CASE(VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI);
  ADD_FLAG_CASE(VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI);
  ADD_FLAG_CASE(VK_SHADER_STAGE_RAYGEN_BIT_NV);
  ADD_FLAG_CASE(VK_SHADER_STAGE_ANY_HIT_BIT_NV);
  ADD_FLAG_CASE(VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV);
  ADD_FLAG_CASE(VK_SHADER_STAGE_MISS_BIT_NV);
  ADD_FLAG_CASE(VK_SHADER_STAGE_INTERSECTION_BIT_NV);
  ADD_FLAG_CASE(VK_SHADER_STAGE_CALLABLE_BIT_NV);
  ADD_FLAG_CASE(VK_SHADER_STAGE_TASK_BIT_NV);
  ADD_FLAG_CASE(VK_SHADER_STAGE_MESH_BIT_NV);

  if (!result.empty()) {
    result.erase(result.length() - 3);
  }

#undef ADD_FLAG_CASE

  return result;
}

std::string Log::getSampleCountString(const VkSampleCountFlags& sampleCount) {
  std::string result = "VkSampleCountFlags: ";
#define ADD_FLAG_CASE(flag)                \
  if (sampleCount & flag) {                \
    result += STRINGIFICATION(flag) " | "; \
  }

  ADD_FLAG_CASE(VK_SAMPLE_COUNT_1_BIT);
  ADD_FLAG_CASE(VK_SAMPLE_COUNT_2_BIT);
  ADD_FLAG_CASE(VK_SAMPLE_COUNT_4_BIT);
  ADD_FLAG_CASE(VK_SAMPLE_COUNT_8_BIT);
  ADD_FLAG_CASE(VK_SAMPLE_COUNT_16_BIT);
  ADD_FLAG_CASE(VK_SAMPLE_COUNT_32_BIT);
  ADD_FLAG_CASE(VK_SAMPLE_COUNT_64_BIT);

  if (!result.empty()) {
    result.erase(result.length() - 3);
  }

#undef ADD_FLAG_CASE

  return result;
}

std::string Log::getImageUsageString(const VkImageUsageFlags& usage) {
  std::string result = "VkImageUsageFlags: ";
#define ADD_FLAG_CASE(flag)                \
  if (usage & flag) {                      \
    result += STRINGIFICATION(flag) " | "; \
  }

  ADD_FLAG_CASE(VK_IMAGE_USAGE_TRANSFER_SRC_BIT);
  ADD_FLAG_CASE(VK_IMAGE_USAGE_TRANSFER_DST_BIT);
  ADD_FLAG_CASE(VK_IMAGE_USAGE_SAMPLED_BIT);
  ADD_FLAG_CASE(VK_IMAGE_USAGE_STORAGE_BIT);
  ADD_FLAG_CASE(VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT);
  ADD_FLAG_CASE(VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT);
  ADD_FLAG_CASE(VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT);
  ADD_FLAG_CASE(VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT);
  ADD_FLAG_CASE(VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR);
  ADD_FLAG_CASE(VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR);
  ADD_FLAG_CASE(VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR);
  ADD_FLAG_CASE(VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT);
  ADD_FLAG_CASE(VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR);

  if (!result.empty()) {
    result.erase(result.length() - 3);
  }

#undef ADD_FLAG_CASE
  return result;
}

std::string Log::returnDateAndTime() {
  auto now = std::chrono::system_clock::now();
  std::time_t nowC = std::chrono::system_clock::to_time_t(now);

#ifdef __linux__
  char nowStr[20] = "---";
#elif _WIN32
  std::tm timeInfo;
  gmtime_s(&timeInfo, &nowC);
  char nowStr[20];
  strftime(nowStr, 20, "%y.%m.%d %H:%M:%S", &timeInfo);
#else

#endif

  return std::string(nowStr);
}

#include "CapitalEngine.h"

#include <string>

int main() {
  try {
    CapitalEngine GENERATIONS;
    GENERATIONS.mainLoop();

  } catch (const std::exception& e) {
    Log::text(e.what());
    return EXIT_FAILURE;
  } catch (...) {
    throw std::runtime_error("\n!ERROR! Unknown error caught in main()");
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}

#include "vulkan/vulkan.h"

#include "CapitalEngine.h"
#include "Mechanics.h"

VulkanMechanics::VulkanMechanics()
    : initVulkan{},
      mainDevice{initVulkan, queues, swapchain},
      queues{},
      swapchain{initVulkan.surface, queues},
      syncObjects{} {
  Log::text("{ Vk. }", "constructing Vulkan Mechanics");
  Log::text(Log::Style::headerGuard);
}

VulkanMechanics::~VulkanMechanics() {
  Log::text("{ Vk. }", "destructing Vulkan Mechanics");
}

void VulkanMechanics::Swapchain::recreate(const VkSurfaceKHR& surface,
                                          const CE::Queues& queues,
                                          SynchronizationObjects& syncObjects,
                                          Pipelines& pipelines,
                                          Resources& resources) {
  CE::Swapchain::recreate(surface, queues, syncObjects);
  resources.msaaImage.createResources(extent, imageFormat,
                                      VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT |
                                          VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
                                      VK_IMAGE_ASPECT_COLOR_BIT);
  resources.depthImage.createResources(
      extent, CE::Image::findDepthFormat(),
      VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_ASPECT_DEPTH_BIT);
  pipelines.render.createFramebuffers(*this, resources.msaaImage.view,
                                      resources.depthImage.view);

  resources.storageImage.createDescriptorWrite(images);
  CE::Descriptor::updateSets(CE::Descriptor::sets,
                             CE::Descriptor::descriptorWrites);
}

#include <vulkan/vulkan.h>

#include "CapitalEngine.h"
#include "Pipelines.h"

Pipelines::Pipelines(VulkanMechanics& mechanics, Resources& resources)
    : compute{resources.pushConstants},
      graphics{},
      render{mechanics.swapchain, resources.msaaImage,
             resources.depthImage.view},
      config{render.renderPass, graphics.layout, compute.layout,
             resources.msaaImage.info.samples, resources.world.grid.size} {
  Log::text("{ === }", "constructing Pipelines");
}

Pipelines::~Pipelines() {
  Log::text("{ === }", "destructing Pipelines");
}

#include "vulkan/vulkan.h"

#include "CapitalEngine.h"
#include "Resources.h"

Resources::Resources(VulkanMechanics& mechanics, Pipelines& pipelines)
    : commands{mechanics.queues.familyIndices},
      pushConstants{},
      depthImage{mechanics.swapchain.extent, CE::Image::findDepthFormat()},
      msaaImage{mechanics.swapchain.extent, mechanics.swapchain.imageFormat},
      shaderStorage{commands.singularCommandBuffer, commands.pool,
                    mechanics.queues.graphics, world.grid.cells,
                    world.grid.pointCount},
      sampler{commands.singularCommandBuffer, commands.pool,
              mechanics.queues.graphics, mechanics.swapchain},
      storageImage{mechanics.swapchain.images},
      world{commands.singularCommandBuffer, commands.pool,
            mechanics.queues.graphics} {
  Log::text(Log::Style::headerGuard);
  Log::text("{ /// }", "constructing Resources");

  CE::Descriptor::createSetLayout(CE::Descriptor::setLayoutBindings);
  CE::Descriptor::createPool();
  CE::Descriptor::allocateSets();
  CE::Descriptor::updateSets(CE::Descriptor::sets,
                             CE::Descriptor::descriptorWrites);
}

Resources::~Resources() {
  Log::text("{ /// }", "destructing Resources");
}

Resources::Commands::Commands(const CE::Queues::FamilyIndices& familyIndices) {
  createPool(familyIndices);
  createBuffers(graphics);
  createBuffers(compute);
}

Resources::DepthImage::DepthImage(const VkExtent2D extent,
                                  const VkFormat format) {
  createResources(extent, format, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
                  VK_IMAGE_ASPECT_DEPTH_BIT);
}

Resources::MultisamplingImage::MultisamplingImage(const VkExtent2D extent,
                                                  const VkFormat format) {
  createResources(extent, format,
                  VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT |
                      VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
                  VK_IMAGE_ASPECT_COLOR_BIT);
}

Resources::UniformBuffer::UniformBuffer() {
  myIndex = writeIndex;
  writeIndex++;

  VkDescriptorType type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
  setLayoutBinding.binding = 0;
  setLayoutBinding.descriptorType = type;
  setLayoutBinding.descriptorCount = 1;
  setLayoutBinding.stageFlags =
      VK_SHADER_STAGE_COMPUTE_BIT | VK_SHADER_STAGE_VERTEX_BIT;
  setLayoutBindings[myIndex] = setLayoutBinding;

  poolSize.type = type;
  poolSize.descriptorCount = MAX_FRAMES_IN_FLIGHT;
  poolSizes.push_back(poolSize);

  createBuffer();

  createDescriptorWrite();
}

void Resources::UniformBuffer::createBuffer() {
  Log::text("{ 101 }", MAX_FRAMES_IN_FLIGHT, "Uniform Buffers");
  VkDeviceSize bufferSize = sizeof(World::UniformBufferObject);

  CE::Buffer::create(bufferSize, VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
                     VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
                         VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                     buffer);

  vkMapMemory(CE::Device::baseDevice->logical, buffer.memory, 0, bufferSize, 0,
              &buffer.mapped);
}

void Resources::UniformBuffer::createDescriptorWrite() {
  VkDescriptorBufferInfo bufferInfo{
      .buffer = buffer.buffer, .range = sizeof(World::UniformBufferObject)};
  info.currentFrame = bufferInfo;

  VkWriteDescriptorSet descriptorWrite{
      .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
      .dstBinding = setLayoutBinding.binding,
      .descriptorCount = setLayoutBinding.descriptorCount,
      .descriptorType = setLayoutBinding.descriptorType,
      .pBufferInfo = &std::get<VkDescriptorBufferInfo>(info.currentFrame)};

  for (uint32_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
    descriptorWrites[i][myIndex] = descriptorWrite;
  }
};

void Resources::UniformBuffer::update(World& world, const VkExtent2D extent) {
  object.light = world.light.position;
  object.gridXY = glm::vec2(static_cast<uint32_t>(world.grid.size.x),
                            static_cast<uint32_t>(world.grid.size.y));
  object.waterThreshold = 0.1f;
  object.cellSize = world.grid.initialCellSize;
  object.model = world.camera.setModel();
  object.view = world.camera.setView();
  object.projection = world.camera.setProjection(extent);

  std::memcpy(buffer.mapped, &object, sizeof(object));
}

Resources::StorageBuffer::StorageBuffer(VkCommandBuffer& commandBuffer,
                                        const VkCommandPool& commandPool,
                                        const VkQueue& queue,
                                        const auto& object,
                                        const size_t quantity) {
  myIndex = writeIndex;
  writeIndex += 2;

  setLayoutBinding.binding = 1;
  setLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
  setLayoutBinding.descriptorCount = 1;
  setLayoutBinding.stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
  setLayoutBindings[myIndex] = setLayoutBinding;
  setLayoutBinding.binding = 2;
  setLayoutBindings[myIndex + 1] = setLayoutBinding;

  poolSize.type = setLayoutBinding.descriptorType;
  poolSize.descriptorCount = MAX_FRAMES_IN_FLIGHT * 2;
  poolSizes.push_back(poolSize);

  create(commandBuffer, commandPool, queue, object, quantity);

  createDescriptorWrite(quantity);
}

void Resources::StorageBuffer::create(VkCommandBuffer& commandBuffer,
                                      const VkCommandPool& commandPool,
                                      const VkQueue& queue,
                                      const auto& object,

                                      const size_t quantity) {
  Log::text("{ 101 }", "Shader Storage Buffers");

  // Create a staging buffer used to upload data to the gpu
  CE::Buffer stagingResources;
  VkDeviceSize bufferSize = sizeof(World::Cell) * quantity;

  CE::Buffer::create(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                     VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
                         VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                     stagingResources);

  void* data;
  vkMapMemory(CE::Device::baseDevice->logical, stagingResources.memory, 0,
              bufferSize, 0, &data);
  std::memcpy(data, object.data(), static_cast<size_t>(bufferSize));
  vkUnmapMemory(CE::Device::baseDevice->logical, stagingResources.memory);

  CE::Buffer::create(static_cast<VkDeviceSize>(bufferSize),
                     VK_BUFFER_USAGE_STORAGE_BUFFER_BIT |
                         VK_BUFFER_USAGE_VERTEX_BUFFER_BIT |
                         VK_BUFFER_USAGE_TRANSFER_DST_BIT,
                     VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, bufferIn);
  CE::Buffer::copy(stagingResources.buffer, bufferIn.buffer, bufferSize,
                   commandBuffer, commandPool, queue);

  CE::Buffer::create(static_cast<VkDeviceSize>(bufferSize),
                     VK_BUFFER_USAGE_STORAGE_BUFFER_BIT |
                         VK_BUFFER_USAGE_VERTEX_BUFFER_BIT |
                         VK_BUFFER_USAGE_TRANSFER_DST_BIT,
                     VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, bufferOut);
  CE::Buffer::copy(stagingResources.buffer, bufferOut.buffer, bufferSize,
                   commandBuffer, commandPool, queue);
}

void Resources::StorageBuffer::createDescriptorWrite(const size_t quantity) {
  for (uint32_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
    VkDescriptorBufferInfo bufferInfo{
        .buffer = !i ? bufferIn.buffer : bufferOut.buffer,
        .offset = 0,
        .range = sizeof(World::Cell) * quantity};

    !i ? info.currentFrame = bufferInfo : info.previousFrame = bufferInfo;

    VkWriteDescriptorSet descriptorWrite{
        .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
        .dstBinding = static_cast<uint32_t>(i ? 2 : 1),
        .descriptorCount = setLayoutBinding.descriptorCount,
        .descriptorType = setLayoutBinding.descriptorType,
        .pBufferInfo = &std::get<VkDescriptorBufferInfo>(info.currentFrame)};

    descriptorWrites[i][myIndex] = descriptorWrite;
    descriptorWrite.dstBinding = static_cast<uint32_t>(i ? 1 : 2);
    descriptorWrite.pBufferInfo =
        &std::get<VkDescriptorBufferInfo>(info.previousFrame);
    descriptorWrites[i][myIndex + 1] = descriptorWrite;
  }
};

Resources::ImageSampler::ImageSampler(VkCommandBuffer& commandBuffer,
                                      VkCommandPool& commandPool,
                                      const VkQueue& queue, CE::Swapchain& swapchain) {
  myIndex = writeIndex;
  writeIndex++;

  setLayoutBinding.binding = 3;
  setLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
  setLayoutBinding.descriptorCount = 1;
  setLayoutBinding.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
  setLayoutBindings[myIndex] = setLayoutBinding;

  poolSize.type = setLayoutBinding.descriptorType;
  poolSize.descriptorCount = MAX_FRAMES_IN_FLIGHT;
  poolSizes.push_back(poolSize);

  //textureImage.loadTexture(textureImage.path, VK_FORMAT_R8G8B8A8_SRGB,
  //                         commandBuffer, commandPool, queue);
  textureImage.useSwapchainImages(swapchain, commandBuffer, commandPool, queue);
  textureImage.createView(VK_IMAGE_ASPECT_COLOR_BIT);
  textureImage.createSampler();

  createDescriptorWrite();
}

void Resources::ImageSampler::createDescriptorWrite() {
  VkDescriptorImageInfo imageInfo{
      .sampler = textureImage.sampler,
      .imageView = textureImage.view,
      .imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL};
  info.currentFrame = imageInfo;

  VkWriteDescriptorSet descriptorWrite{
      .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
      .dstBinding = setLayoutBinding.binding,
      .descriptorCount = setLayoutBinding.descriptorCount,
      .descriptorType = setLayoutBinding.descriptorType,
      .pImageInfo = &std::get<VkDescriptorImageInfo>(info.currentFrame)};

  for (uint32_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
    descriptorWrites[i][myIndex] = descriptorWrite;
  }
}

Resources::StorageImage::StorageImage(
    std::array<CE::Image, MAX_FRAMES_IN_FLIGHT>& images) {
  myIndex = writeIndex;
  writeIndex++;

  setLayoutBinding.binding = 4;
  setLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
  setLayoutBinding.descriptorCount = 1;
  setLayoutBinding.stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;
  setLayoutBindings[myIndex] = setLayoutBinding;

  poolSize.type = setLayoutBinding.descriptorType;
  poolSize.descriptorCount = MAX_FRAMES_IN_FLIGHT;
  poolSizes.push_back(poolSize);

  createDescriptorWrite(images);
}

void Resources::StorageImage::createDescriptorWrite(
    std::array<CE::Image, MAX_FRAMES_IN_FLIGHT>& images) {
  for (uint32_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
    VkDescriptorImageInfo imageInfo{.sampler = VK_NULL_HANDLE,
                                    .imageView = images[i].view,
                                    .imageLayout = VK_IMAGE_LAYOUT_GENERAL};

    !i ? info.currentFrame = imageInfo : info.previousFrame = imageInfo;

    VkWriteDescriptorSet descriptorWrite{
        .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
        .dstBinding = setLayoutBinding.binding,
        .descriptorCount = setLayoutBinding.descriptorCount,
        .descriptorType = setLayoutBinding.descriptorType,
        .pImageInfo = &std::get<VkDescriptorImageInfo>(
            !i ? info.currentFrame : info.previousFrame)};

    descriptorWrites[i][myIndex] = descriptorWrite;
  }
}

void Resources::Commands::recordComputeCommandBuffer(
    Resources& resources,
    Pipelines& pipelines,
    const uint32_t imageIndex) {
  VkCommandBuffer commandBuffer = this->compute[imageIndex];

  VkCommandBufferBeginInfo beginInfo{
      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};

  if (vkBeginCommandBuffer(commandBuffer, &beginInfo) != VK_SUCCESS) {
    throw std::runtime_error(
        "failed to begin recording compute command buffer!");
  }

  vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_COMPUTE,
                    pipelines.config.getPipelineObjectByName("Engine"));

  vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_COMPUTE,
                          pipelines.compute.layout, 0, 1,
                          &CE::Descriptor::sets[imageIndex], 0, nullptr);

  resources.pushConstants.setData(resources.world.time.passedHours);

  vkCmdPushConstants(
      commandBuffer, pipelines.compute.layout,
      resources.pushConstants.shaderStage, resources.pushConstants.offset,
      resources.pushConstants.size, resources.pushConstants.data.data());

  const std::array<uint32_t, 3>& workGroups =
      pipelines.config.getWorkGroupsByName("Engine");
  vkCmdDispatch(commandBuffer, workGroups[0], workGroups[0], workGroups[2]);

  CE::VULKAN_RESULT(vkEndCommandBuffer, commandBuffer);
}

void Resources::Commands::recordGraphicsCommandBuffer(
    CE::Swapchain& swapchain,
    Resources& resources,
    Pipelines& pipelines,
    const uint32_t imageIndex) {
  VkCommandBuffer commandBuffer = this->graphics[imageIndex];

  VkCommandBufferBeginInfo beginInfo{
      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};

  CE::VULKAN_RESULT(vkBeginCommandBuffer, commandBuffer, &beginInfo);

  std::array<VkClearValue, 2> clearValues{
      VkClearValue{.color = {{0.0f, 0.0f, 0.0f, 1.0f}}},
      VkClearValue{.depthStencil = {1.0f, 0}}};

  VkRenderPassBeginInfo renderPassInfo{
      .sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
      .pNext = nullptr,
      .renderPass = pipelines.render.renderPass,
      .framebuffer = swapchain.framebuffers[imageIndex],
      .renderArea = {.offset = {0, 0}, .extent = swapchain.extent},
      .clearValueCount = static_cast<uint32_t>(clearValues.size()),
      .pClearValues = clearValues.data()};

  vkCmdBeginRenderPass(commandBuffer, &renderPassInfo,
                       VK_SUBPASS_CONTENTS_INLINE);
  VkViewport viewport{.x = 0.0f,
                      .y = 0.0f,
                      .width = static_cast<float>(swapchain.extent.width),
                      .height = static_cast<float>(swapchain.extent.height),
                      .minDepth = 0.0f,
                      .maxDepth = 1.0f};
  vkCmdSetViewport(commandBuffer, 0, 1, &viewport);

  VkRect2D scissor{.offset = {0, 0}, .extent = swapchain.extent};
  vkCmdSetScissor(commandBuffer, 0, 1, &scissor);

  vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS,
                          pipelines.graphics.layout, 0, 1,
                          &CE::Descriptor::sets[imageIndex], 0, nullptr);

  // Pipeline 1
  vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS,
                    pipelines.config.getPipelineObjectByName("Cells"));
  VkDeviceSize offsets[]{0};

  VkDeviceSize offsets0[]{0, 0};

  VkBuffer currentShaderStorageBuffer[] = {
      resources.shaderStorage.bufferIn.buffer,
      resources.shaderStorage.bufferOut.buffer};

  VkBuffer vertexBuffers0[] = {currentShaderStorageBuffer[imageIndex],
                               resources.world.cube.vertexBuffer.buffer};

  vkCmdBindVertexBuffers(commandBuffer, 0, 2, vertexBuffers0, offsets0);
  vkCmdDraw(commandBuffer,
            static_cast<uint32_t>(resources.world.cube.allVertices.size()),
            resources.world.grid.size.x * resources.world.grid.size.y, 0, 0);

  // Landscape
  vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS,
                    pipelines.config.getPipelineObjectByName("Landscape"));
  VkBuffer vertexBuffers1[] = {resources.world.grid.vertexBuffer.buffer};
  vkCmdBindVertexBuffers(commandBuffer, 0, 1, vertexBuffers1, offsets);
  vkCmdBindIndexBuffer(commandBuffer, resources.world.grid.indexBuffer.buffer,
                       0, VK_INDEX_TYPE_UINT32);
  vkCmdDrawIndexed(commandBuffer,
                   static_cast<uint32_t>(resources.world.grid.indices.size()),
                   1, 0, 0, 0);

  //   Landscape Wireframe
  vkCmdBindPipeline(
      commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS,
      pipelines.config.getPipelineObjectByName("LandscapeWireFrame"));
  vkCmdDrawIndexed(commandBuffer,
                   static_cast<uint32_t>(resources.world.grid.indices.size()),
                   1, 0, 0, 0);

  // Pipeline 3
  vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS,
                    pipelines.config.getPipelineObjectByName("Water"));
  VkBuffer vertexBuffers[] = {resources.world.rectangle.vertexBuffer.buffer};
  vkCmdBindVertexBuffers(commandBuffer, 0, 1, vertexBuffers, offsets);
  vkCmdBindIndexBuffer(commandBuffer,
                       resources.world.rectangle.indexBuffer.buffer, 0,
                       VK_INDEX_TYPE_UINT32);
  vkCmdDrawIndexed(
      commandBuffer,
      static_cast<uint32_t>(resources.world.rectangle.indices.size()), 1, 0, 0,
      0);

  // Pipeline 4
  vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS,
                    pipelines.config.getPipelineObjectByName("Texture"));
  vkCmdDrawIndexed(
      commandBuffer,
      static_cast<uint32_t>(resources.world.rectangle.indices.size()), 1, 0, 0,
      0);
  vkCmdEndRenderPass(commandBuffer);

  //       This is part of an image memory barrier (i.e., vkCmdPipelineBarrier
  //       with the VkImageMemoryBarrier parameter set)

  swapchain.images[imageIndex].transitionLayout(
      commandBuffer, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
      /* -> */ VK_IMAGE_LAYOUT_GENERAL);

  // vkDeviceWaitIdle(_mainDevice.logical);

  vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_COMPUTE,
                    pipelines.config.getPipelineObjectByName("PostFX"));

  vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_COMPUTE,
                          pipelines.compute.layout, 0, 1,
                          &CE::Descriptor::sets[imageIndex], 0, nullptr);

  resources.pushConstants.setData(resources.world.time.passedHours);
  vkCmdPushConstants(
      commandBuffer, pipelines.compute.layout,
      resources.pushConstants.shaderStage, resources.pushConstants.offset,
      resources.pushConstants.size, resources.pushConstants.data.data());

  const std::array<uint32_t, 3>& workGroups =
      pipelines.config.getWorkGroupsByName("PostFX");
  vkCmdDispatch(commandBuffer, workGroups[0], workGroups[1], workGroups[2]);

  swapchain.images[imageIndex].transitionLayout(
      commandBuffer, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_LAYOUT_GENERAL,
      /* -> */ VK_IMAGE_LAYOUT_PRESENT_SRC_KHR);

  CE::VULKAN_RESULT(vkEndCommandBuffer, commandBuffer);
}

#include <glm/glm.hpp>
#include <glm/gtc/noise.hpp>

#include "CapitalEngine.h"
#include "Terrain.h"

#include <cmath>
#include <vector>

Terrain::Terrain(const Config& config) : config(config) {}

std::vector<float> Terrain::generatePerlinGrid() {
  uint_fast16_t pointCount = config.dimensions.x * config.dimensions.y;
  std::vector<float> randomValues(pointCount);

  for (uint_fast16_t i = 0; i < pointCount; i++) {
    glm::vec2 position(i % config.dimensions.x, i / config.dimensions.x);
    glm::vec2 scaledPosition =
        position / glm::vec2(config.dimensions.x, config.dimensions.y);

    float totalNoise = 0.0f;
    float frequency = config.frequency;
    float amplitude = config.amplitude;

    for (int octave = 0; octave < config.octaves; octave++) {
      totalNoise +=
          glm::perlin(scaledPosition * config.scale * frequency) * amplitude;
      frequency *= 2.0f;
      amplitude *= config.roughness;
    }

    totalNoise = pow(totalNoise, config.exponent);

    randomValues[i] = totalNoise + config.heightOffset;
  }
  return randomValues;
}

float Terrain::linearInterpolationFunction(float a, float b, float t) {
  return a * (1.0f - t) + b * t;
}

#include "Timer.h"

#include <chrono>

Timer::Timer(float initSpeed) : speed{initSpeed} {}

void Timer::run() {
  static auto lastTime = std::chrono::steady_clock::now();
  static std::chrono::time_point<std::chrono::steady_clock> dayStart =
      std::chrono::steady_clock::now();

  auto currentTime = std::chrono::steady_clock::now();

  if (currentTime - lastTime >= std::chrono::duration<float>(1.0f / speed)) {
    passedHours++;
    lastTime = currentTime;
  }

  std::chrono::duration<float> elapsedTime = currentTime - dayStart;
  std::chrono::duration<float> remainingTime =
      std::chrono::duration<float>(TARGET_DURATION) - elapsedTime;
  float elapsedSeconds = elapsedTime.count();
  float remainingSeconds = remainingTime.count();

  dayFraction = 1.0f - remainingSeconds / TARGET_DURATION;

  if (elapsedTime >= std::chrono::duration<float>(TARGET_DURATION)) {
    dayStart = currentTime;
  }

  if (speed <= TRIGGER_DELAY_UNDER_SPEED) {
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
  }

  return;
}

#include "ValidationLayers.h"
#include "CapitalEngine.h"

#include <set>

ValidationLayers::ValidationLayers()
    : debugMessenger{}, validation{"VK_LAYER_KHRONOS_validation"} {}

ValidationLayers::~ValidationLayers() {}

void ValidationLayers::logValidationMessage(const std::string& string,
                                            const std::string& excludeError) {
  if (string.find(excludeError) != std::string::npos)
    return;

  Log::text("!!!!!!!", "Validation Layer: ", string, "\n");
}

VkResult ValidationLayers::CreateDebugUtilsMessengerEXT(
    VkInstance instance,
    const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkDebugUtilsMessengerEXT* pDebugMessenger) {
  auto func = (PFN_vkCreateDebugUtilsMessengerEXT)vkGetInstanceProcAddr(
      instance, "vkCreateDebugUtilsMessengerEXT");
  if (func == nullptr) {
    return VK_ERROR_EXTENSION_NOT_PRESENT;
  }
  return func(instance, pCreateInfo, pAllocator, pDebugMessenger);
}

void ValidationLayers::DestroyDebugUtilsMessengerEXT(
    VkInstance instance,
    VkDebugUtilsMessengerEXT debugMessenger,
    const VkAllocationCallbacks* pAllocator) {
  auto func = (PFN_vkDestroyDebugUtilsMessengerEXT)vkGetInstanceProcAddr(
      instance, "vkDestroyDebugUtilsMessengerEXT");
  if (func != nullptr) {
    func(instance, debugMessenger, pAllocator);
  }
}

void ValidationLayers::populateDebugMessengerCreateInfo(
    VkDebugUtilsMessengerCreateInfoEXT& createInfo) {
  createInfo = {
      .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
      .messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |
                         VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT,
      .messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |
                     VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |
                     VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT,
      .pfnUserCallback = debugCallback};
}

void ValidationLayers::setupDebugMessenger(VkInstance instance) {
  if (!enableValidationLayers)
    return;

  VkDebugUtilsMessengerCreateInfoEXT createInfo;
  populateDebugMessengerCreateInfo(createInfo);

  if (CreateDebugUtilsMessengerEXT(instance, &createInfo, nullptr,
                                   &debugMessenger) != VK_SUCCESS)
    throw std::runtime_error("\n!ERROR! Failed to set up debug messenger!");
}

bool ValidationLayers::checkValidationLayerSupport() {
  uint32_t layerCount;
  vkEnumerateInstanceLayerProperties(&layerCount, nullptr);

  std::vector<VkLayerProperties> availableLayers(layerCount);
  vkEnumerateInstanceLayerProperties(&layerCount, availableLayers.data());

  std::set<std::string> availableLayerNames;
  for (const auto& layer : availableLayers) {
    availableLayerNames.insert(layer.layerName);
  }

  for (const auto& layerName : validation) {
    if (availableLayerNames.find(layerName) == availableLayerNames.end()) {
      return false;
    }
  }
  return true;
}

#include "Window.h"
#include "CapitalEngine.h"

#include <unordered_map>

Window Window::mainWindow;

Window::Window() : window{nullptr}, framebufferResized{false}, mouse{} {
  Log::logTitle();
  Log::text("{ [-] }", "constructing Window");
  initWindow();
}

Window::~Window() {
  Log::text("{ [-] }", "destructing Window");
  Log::logFooter();

  glfwDestroyWindow(window);
  glfwTerminate();
}

void Window::initWindow() {
  glfwInit();
  glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
  window = glfwCreateWindow(display.width, display.height, display.title,
                            nullptr, nullptr);
  glfwSetWindowUserPointer(window, this);
  glfwSetFramebufferSizeCallback(window, windowResize);
  Log::text("{ [*] }", "Window initialized", display.width, "*",
            display.height);
}

void Window::windowResize(GLFWwindow* win, int width, int height) {
  auto app = reinterpret_cast<Window*>(glfwGetWindowUserPointer(win));
  app->framebufferResized = true;
  app->display.width = width;
  app->display.height = height;
  Log::text("{ [*] }", "Window resized to", width, "*", height);
}

void Window::setMouse() {
  int newState = GLFW_RELEASE;
  static int buttonType = -1;
  const static std::vector<uint32_t> mouseButtonTypes{GLFW_MOUSE_BUTTON_LEFT,
                                                      GLFW_MOUSE_BUTTON_RIGHT,
                                                      GLFW_MOUSE_BUTTON_MIDDLE};

  for (const int mouseButtonType : mouseButtonTypes) {
    if (glfwGetMouseButton(window, mouseButtonType) == GLFW_PRESS) {
      newState = GLFW_PRESS;
      buttonType = mouseButtonType;
      break;
    }
  }

  if (buttonType != -1) {
    static int oldState = GLFW_RELEASE;
    double xpos, ypos;
    static float pressTime = 0.0f;

    glfwGetCursorPos(window, &xpos, &ypos);
    const float x = static_cast<float>(xpos) / display.width;
    const float y = static_cast<float>(ypos) / display.height;

    static const std::unordered_map<int, std::string> buttonMappings = {
        {GLFW_MOUSE_BUTTON_LEFT, "{ --> } Left Mouse Button"},
        {GLFW_MOUSE_BUTTON_RIGHT, "{ --> } Right Mouse Button"},
        {GLFW_MOUSE_BUTTON_MIDDLE, "{ --> } Middle Mouse Button"}};

    switch (oldState) {
      case GLFW_PRESS: {
        if (newState == GLFW_RELEASE) {
          const std::unordered_map<int, std::string>::const_iterator&
              buttonMapping = buttonMappings.find(buttonType);
          if (buttonMapping != buttonMappings.end()) {
            const std::string& message = buttonMapping->second;
            mouse.buttonClick[buttonType].position = glm::vec2{x, y};

            Log::text(message + " clicked at",
                      mouse.buttonClick[buttonType].position.x, ":",
                      mouse.buttonClick[buttonType].position.y);
          }
        } else {
          const float currentTime = static_cast<float>(glfwGetTime());
          const float timer = currentTime - pressTime;
          if (timer >= mouse.pressDelay) {
            const std::unordered_map<int, std::string>::const_iterator&
                buttonMapping = buttonMappings.find(buttonType);
            if (buttonMapping != buttonMappings.end()) {
              const std::string& message = buttonMapping->second;
              glm::vec2 normalizedCoords =
                  glm::vec2(x, y) * glm::vec2(2.0f, 2.0f) -
                  glm::vec2(1.0f, 1.0f);
              mouse.buttonDown[buttonType].position +=
                  normalizedCoords * mouse.speed;

              // Log::text(message + " moved to",
              //              mouse.buttonDown[buttonType].position.x, ":",
              //              mouse.buttonDown[buttonType].position.y);
            }
          }
        }
        break;
      }
      case GLFW_RELEASE: {
        pressTime =
            (newState == GLFW_PRESS) ? static_cast<float>(glfwGetTime()) : 0.0f;
        break;
      }
    }
    oldState = newState;
  }
}

#include "World.h"
#include "CapitalEngine.h"
#include "Terrain.h"

#include <algorithm>
#include <cstdlib>
#include <ctime>
#include <random>

World::World(VkCommandBuffer& commandBuffer,
             const VkCommandPool& commandPool,
             const VkQueue& queue)
    : grid{commandBuffer, commandPool, queue},
      rectangle{commandBuffer, commandPool, queue},
      cube{commandBuffer, commandPool, queue} {
  Log::text("{ wWw }", "constructing World");
}

World::~World() {
  Log::text("{ wWw }", "destructing World");
}

std::vector<VkVertexInputBindingDescription>
World::Cell::getBindingDescription() {
  std::vector<VkVertexInputBindingDescription> description{
      {0, sizeof(Cell), VK_VERTEX_INPUT_RATE_INSTANCE},
      {1, sizeof(Cube::Vertex), VK_VERTEX_INPUT_RATE_VERTEX}};
  return description;
}

std::vector<VkVertexInputAttributeDescription>
World::Cell::getAttributeDescription() {
  std::vector<VkVertexInputAttributeDescription> description{
      {0, 0, VK_FORMAT_R32G32B32A32_SFLOAT,
       static_cast<uint32_t>(offsetof(Cell, instancePosition))},
      {1, 1, VK_FORMAT_R32G32B32A32_SFLOAT,
       static_cast<uint32_t>(offsetof(Cube::Vertex, vertexPosition))},
      {2, 1, VK_FORMAT_R32G32B32A32_SFLOAT,
       static_cast<uint32_t>(offsetof(Cube::Vertex, normal))},
      {3, 0, VK_FORMAT_R32G32B32A32_SFLOAT,
       static_cast<uint32_t>(offsetof(Cell, color))},
      {4, 0, VK_FORMAT_R32G32B32A32_SINT,
       static_cast<uint32_t>(offsetof(Cell, states))}};
  return description;
};

World::Grid::Grid(VkCommandBuffer& commandBuffer,
                  const VkCommandPool& commandPool,
                  const VkQueue& queue) {
  Terrain::Config terrainLayer1 = {.dimensions = size,
                                   .roughness = 0.4f,
                                   .octaves = 10,
                                   .scale = 1.1f,
                                   .amplitude = 5.0f,
                                   .exponent = 2.0f,
                                   .frequency = 2.0f,
                                   .heightOffset = 0.0f};
  Terrain terrain(terrainLayer1);

  Terrain::Config terrainLayer2 = {.dimensions = size,
                                   .roughness = 1.0f,
                                   .octaves = 10,
                                   .scale = 1.1f,
                                   .amplitude = 0.3f,
                                   .exponent = 1.0f,
                                   .frequency = 2.0f,
                                   .heightOffset = 0.0f};
  Terrain terrainSurface(terrainLayer2);

  std::vector<float> terrainPerlinGrid1 = terrain.generatePerlinGrid();
  std::vector<float> terrainPerlinGrid2 = terrainSurface.generatePerlinGrid();
  const float blendFactor = 0.5f;

  std::vector<bool> isAliveIndices(pointCount, false);
  std::vector<uint_fast32_t> aliveCellIndices =
      setCellsAliveRandomly(initialAliveCells);
  for (int aliveIndex : aliveCellIndices) {
    isAliveIndices[aliveIndex] = true;
  }

  const glm::vec4 red{1.0f, 0.0f, 0.0f, 1.0f};
  const glm::vec4 blue{0.0f, 0.0f, 1.0f, 1.0f};
  const glm::ivec4 alive{1, 0, 0, 0};
  const glm::ivec4 dead{-1, 0, 0, 0};

  const float startX = (size.x - 1) / -2.0f;
  const float startY = (size.y - 1) / -2.0f;
  for (uint_fast32_t i = 0; i < pointCount; ++i) {
    pointIDs[i] = i;

    float height = terrain.linearInterpolationFunction(
        terrainPerlinGrid1[i], terrainPerlinGrid2[i], blendFactor);
    coorindates[i] = {(startX + i % size.x), (startY + i / size.x), height};
    addVertexPosition(coorindates[i]);

    const bool isAlive = isAliveIndices[i];

    cells[i].instancePosition = {coorindates[i],
                                 isAlive ? initialCellSize : 0.0f};
    cells[i].color = isAlive ? blue : red;
    cells[i].states = isAlive ? alive : dead;
  }
  indices = createGridPolygons(pointIDs, static_cast<int>(size.x));
  createVertexBuffer(commandBuffer, commandPool, queue, uniqueVertices);
  createIndexBuffer(commandBuffer, commandPool, queue, indices);
}

World::Rectangle::Rectangle(VkCommandBuffer& commandBuffer,
                            const VkCommandPool& commandPool,
                            const VkQueue& queue)
    : Geometry("Rectangle") {
  createVertexBuffer(commandBuffer, commandPool, queue, uniqueVertices);
  createIndexBuffer(commandBuffer, commandPool, queue, indices);
}

World::Cube::Cube(VkCommandBuffer& commandBuffer,
                  const VkCommandPool& commandPool,
                  const VkQueue& queue)
    : Geometry("Cube") {
  createVertexBuffer(commandBuffer, commandPool, queue, allVertices);
}

std::vector<VkVertexInputAttributeDescription>
World::Grid::getAttributeDescription() {
  std::vector<VkVertexInputAttributeDescription> attributes{
      {0, 0, VK_FORMAT_R32G32B32_SFLOAT,
       static_cast<uint32_t>(offsetof(Grid::Vertex, vertexPosition))}};
  return attributes;
}

std::vector<uint_fast32_t> World::Grid::setCellsAliveRandomly(
    uint_fast32_t numberOfCells) {
  std::vector<uint_fast32_t> CellIDs;
  CellIDs.reserve(numberOfCells);

  std::random_device random;
  std::mt19937 generate(random());
  std::uniform_int_distribution<int> distribution(
      0, static_cast<int>(pointCount) - 1);

  while (CellIDs.size() < numberOfCells) {
    int CellID = distribution(generate);
    if (std::find(CellIDs.begin(), CellIDs.end(), CellID) == CellIDs.end())
        [[likely]] {
      CellIDs.push_back(CellID);
    }
  }
  std::sort(CellIDs.begin(), CellIDs.end());
  return CellIDs;
}

void World::Camera::update() {
  glm::vec2 buttonType[3]{};
  constexpr uint_fast8_t left = 0;
  constexpr uint_fast8_t right = 1;
  constexpr uint_fast8_t middle = 2;
  bool mousePositionChanged = false;
  static bool run = false;

  for (uint_fast8_t i = 0; i < 3; ++i) {
    buttonType[i] = Window::get().mouse.buttonDown[i].position -
                    Window::get().mouse.previousButtonDown[i].position;

    if (Window::get().mouse.buttonDown[i].position !=
        Window::get().mouse.previousButtonDown[i].position) {
      mousePositionChanged = true;
      Window::get().mouse.previousButtonDown[i].position =
          Window::get().mouse.buttonDown[i].position;
    }
  }
  if (mousePositionChanged) {
    run = mousePositionChanged;
  }

  if (run) {
    glm::vec2 leftButtonDelta = buttonType[left];
    glm::vec2 rightButtonDelta = buttonType[right];
    glm::vec2 middleButtonDelta = buttonType[middle];
    glm::vec3 cameraRight = glm::cross(front, up);

    glm::vec3 cameraUp = glm::cross(cameraRight, front);
    position -= panningSpeed * leftButtonDelta.x * cameraRight;
    position -= panningSpeed * leftButtonDelta.y * cameraUp;

    position += zoomSpeed * rightButtonDelta.x * front;
    position.z = std::max(position.z, 0.0f);
  }
  run = mousePositionChanged;
}

glm::mat4 World::Camera::setModel() {
  glm::mat4 model = glm::rotate(glm::mat4(1.0f), glm::radians(0.0f),
                                glm::vec3(0.0f, 0.0f, 1.0f));
  return model;
}

glm::mat4 World::Camera::setView() {
  update();
  glm::mat4 view;
  view = glm::lookAt(position, position + front, up);
  return view;
}

glm::mat4 World::Camera::setProjection(const VkExtent2D& swapchainExtent) {
  glm::mat4 projection = glm::perspective(
      glm::radians(fieldOfView),
      swapchainExtent.width / static_cast<float>(swapchainExtent.height),
      nearClipping, farClipping);

  projection[1][1] *= -1;  // flip y axis
  projection[0][0] *= -1;  // flip x axis

  return projection;
};

// void World::updateCamera() {
//     glm::vec2 buttonType[3]{};
//     constexpr uint_fast8_t left = 0;
//     constexpr uint_fast8_t right = 1;
//     constexpr uint_fast8_t middle = 2;
//     bool mousePositionChanged = false;
//     static bool run = false;
//
//     for (uint_fast8_t i = 0; i < 3; ++i) {
//         buttonType[i] = Window::get().mouse.buttonDown[i].position -
//             Window::get().mouse.previousButtonDown[i].position;
//
//         if (Window::get().mouse.buttonDown[i].position !=
//             Window::get().mouse.previousButtonDown[i].position) {
//             mousePositionChanged = true;
//             Window::get().mouse.previousButtonDown[i].position =
//                 Window::get().mouse.buttonDown[i].position;
//         }
//     }
//     if (mousePositionChanged) {
//         run = mousePositionChanged;
//     }
//
//     if (run) {
//         glm::vec2 leftButtonDelta = buttonType[left];
//         glm::vec2 rightButtonDelta = buttonType[right];
//         glm::vec2 middleButtonDelta = buttonType[middle];
//         glm::vec3 cameraRight = glm::cross(camera.front, camera.up);
//
//          glm::vec2 absDelta = glm::abs(leftButtonDelta);
//          constexpr float rotationSpeed = 0.4f * glm::pi<float>() / 180.0f;
//          glm::vec2 rotationDelta = rotationSpeed * leftButtonDelta;
//          glm::mat4 rotationMatrix(1.0f);
//
//          if (absDelta.y > absDelta.x) {
//            rotationMatrix =
//                glm::rotate(rotationMatrix, -rotationDelta.y, cameraRight);
//          } else if (absDelta.x > absDelta.y) {
//            rotationMatrix = glm::rotate(rotationMatrix, rotationDelta.x,
//            camera.up);
//          }
//          camera.front = glm::normalize(
//              glm::vec3(rotationMatrix * glm::vec4(camera.front, 0.0f)));
//          camera.up =
//              glm::normalize(glm::vec3(rotationMatrix * glm::vec4(camera.up,
//              0.0f)));
//
//            float movementSpeed = getForwardMovement(leftButtonDelta);
//            camera.position += movementSpeed * camera.front;
//         constexpr float panningSpeed = 1.3f;
//         glm::vec3 cameraUp = glm::cross(cameraRight, camera.front);
//         camera.position -= panningSpeed * rightButtonDelta.x * cameraRight;
//         camera.position -= panningSpeed * rightButtonDelta.y * cameraUp;
//
//         constexpr float zoomSpeed = 0.5f;
//         camera.position += zoomSpeed * middleButtonDelta.x * camera.front;
//         camera.position.z = std::max(camera.position.z, 0.0f);
//     }
//     run = mousePositionChanged;
// }

// float World::getForwardMovement(const glm::vec2& leftButtonDelta) {
//   static bool leftMouseButtonDown = false;
//   static float forwardMovement = 0.0f;
//   float leftButtonDeltaLength = glm::length(leftButtonDelta);
//
//   if (leftButtonDeltaLength > 0.0f) {
//     if (!leftMouseButtonDown) {
//       leftMouseButtonDown = true;
//       forwardMovement = 0.0f;
//     }
//     constexpr float maxSpeed = 0.1f;
//     constexpr float acceleration = 0.01f;
//
//     // Calculate the speed based on the distance from the center
//     float normalizedDeltaLength = glm::clamp(leftButtonDeltaLength,
//     0.0f, 1.0f); float targetSpeed =
//         glm::smoothstep(0.0f, maxSpeed, 1.0f - normalizedDeltaLength);
//     forwardMovement += acceleration * (targetSpeed - forwardMovement);
//     forwardMovement = glm::clamp(forwardMovement, 0.0f, maxSpeed);
//   } else {
//     leftMouseButtonDown = false;
//     forwardMovement = 0.0f;
//   }
//   return forwardMovement;
// }

#pragma once
#include <vulkan/vulkan.h>

#include "Log.h"
#include "ValidationLayers.h"
#include "Window.h"

#include <memory>
#include <optional>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <utility>
#include <variant>
#include <vector>

constexpr uint32_t MAX_FRAMES_IN_FLIGHT = 2;
constexpr size_t NUM_DESCRIPTORS = 5;

class VulkanMechanics;
class Resources;
class Pipelines;

namespace CE {
class Swapchain;

// Mechanics
class Queues {
 public:
  VkQueue graphics{};
  VkQueue compute{};
  VkQueue present{};
  struct FamilyIndices {
    std::optional<uint32_t> graphicsAndComputeFamily{};
    std::optional<uint32_t> presentFamily{};
    const bool isComplete() const {
      return graphicsAndComputeFamily.has_value() && presentFamily.has_value();
    }
  };
  FamilyIndices familyIndices{};

  Queues() = default;
  virtual ~Queues() = default;
  const FamilyIndices findQueueFamilies(const VkPhysicalDevice& physicalDevice,
                                        const VkSurfaceKHR& surface) const;
};

class InitializeVulkan {
 public:
  VkSurfaceKHR surface{};
  VkInstance instance{};
  ValidationLayers validation{};

  InitializeVulkan();
  virtual ~InitializeVulkan();

 private:
  void createInstance();
  void createSurface(GLFWwindow* window);
  std::vector<const char*> getRequiredExtensions() const;
};

class Device {
 public:
  VkPhysicalDevice physical{VK_NULL_HANDLE};
  VkPhysicalDeviceFeatures features{};
  VkSampleCountFlagBits maxUsableSampleCount{VK_SAMPLE_COUNT_1_BIT};
  VkDevice logical{VK_NULL_HANDLE};

  static Device* baseDevice;

  Device() = default;
  virtual ~Device() { destroyDevice(); }

 protected:
  void pickPhysicalDevice(const InitializeVulkan& initVulkan,
                          Queues& queues,
                          Swapchain& swapchain);
  void createLogicalDevice(const InitializeVulkan& initVulkan, Queues& queues);
  void destroyDevice();

 private:
  VkPhysicalDeviceProperties properties{};
  std::vector<const char*> extensions{VK_KHR_SWAPCHAIN_EXTENSION_NAME};
  static std::vector<VkDevice> destroyedDevices;

  const std::vector<VkDeviceQueueCreateInfo> fillQueueCreateInfos(
      const Queues& queues) const;
  const VkDeviceCreateInfo getDeviceCreateInfo(
      const std::vector<VkDeviceQueueCreateInfo>& queueCreateInfos) const;
  void setValidationLayers(const InitializeVulkan& initVulkan,
                           VkDeviceCreateInfo& createInfo);
  const std::vector<VkPhysicalDevice> fillDevices(
      const InitializeVulkan& initVulkan) const;
  const bool isDeviceSuitable(const VkPhysicalDevice& physical,
                              Queues& queues,
                              const InitializeVulkan& initVulkan,
                              Swapchain& swapchain);
  void getMaxUsableSampleCount();
  const bool checkDeviceExtensionSupport(
      const VkPhysicalDevice& physical) const;
};

class CommandBuffers {
 public:
  VkCommandPool pool{};
  std::array<VkCommandBuffer, MAX_FRAMES_IN_FLIGHT> graphics{};
  std::array<VkCommandBuffer, MAX_FRAMES_IN_FLIGHT> compute{};
  static VkCommandBuffer singularCommandBuffer;

  CommandBuffers() = default;
  virtual ~CommandBuffers();
  static void beginSingularCommands(const VkCommandPool& commandPool,
                                    const VkQueue& queue);
  static void endSingularCommands(const VkCommandPool& commandPool,
                                  const VkQueue& queue);
  virtual void recordComputeCommandBuffer(Resources& resources,
                                          Pipelines& pipelines,
                                          const uint32_t imageIndex) = 0;
  virtual void recordGraphicsCommandBuffer(Swapchain& swapchain,
                                           Resources& resources,
                                           Pipelines& pipelines,
                                           const uint32_t imageIndex) = 0;

 protected:
  void createPool(const Queues::FamilyIndices& familyIndices);
  void createBuffers(
      std::array<VkCommandBuffer, MAX_FRAMES_IN_FLIGHT>& commandBuffers) const;
};

class Buffer {
 public:
  VkBuffer buffer{};
  VkDeviceMemory memory{};
  void* mapped{};

  Buffer() = default;
  virtual ~Buffer();
  static void create(const VkDeviceSize& size,
                     const VkBufferUsageFlags& usage,
                     const VkMemoryPropertyFlags& properties,
                     Buffer& buffer);
  static void copy(const VkBuffer& srcBuffer,
                   VkBuffer& dstBuffer,
                   const VkDeviceSize size,
                   VkCommandBuffer& commandBuffer,
                   const VkCommandPool& commandPool,
                   const VkQueue& queue);
  static void copyToImage(const VkBuffer& buffer,
                          VkImage& image,
                          const uint32_t width,
                          const uint32_t height,
                          VkCommandBuffer& commandBuffer,
                          const VkCommandPool& commandPool,
                          const VkQueue& queue);
};
class Image {
 public:
  VkImage image{};
  VkDeviceMemory memory{};
  VkImageView view{};
  VkSampler sampler{};
  std::string path{};
  VkImageCreateInfo info{.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
                         .pNext = nullptr,
                         .flags = 0,
                         .imageType = VK_IMAGE_TYPE_2D,
                         .format = VK_FORMAT_UNDEFINED,
                         .extent = {.width = 0, .height = 0, .depth = 1},
                         .mipLevels = 1,
                         .arrayLayers = 1,
                         .samples = VK_SAMPLE_COUNT_1_BIT,
                         .tiling = VK_IMAGE_TILING_OPTIMAL,
                         .usage = 0,
                         .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
                         .queueFamilyIndexCount = 0,
                         .pQueueFamilyIndices = nullptr,
                         .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED};

  Image() = default;
  virtual ~Image() { destroyVulkanImages(); };

  void create(const uint32_t width,
              const uint32_t height,
              const VkSampleCountFlagBits numSamples,
              const VkFormat format,
              const VkImageTiling tiling,
              const VkImageUsageFlags& usage,
              const VkMemoryPropertyFlags& properties);
  void recreate() { this->destroyVulkanImages(); };
  void createView(const VkImageAspectFlags aspectFlags);
  void createSampler();
  void createResources(const VkExtent2D& dimensions,
                       const VkFormat format,
                       const VkImageUsageFlags usage,
                       const VkImageAspectFlagBits aspect);
  void transitionLayout(const VkCommandBuffer& commandBuffer,
                        const VkFormat format,
                        const VkImageLayout oldLayout,
                        const VkImageLayout newLayout);
  void loadTexture(const std::string& imagePath,
      const VkFormat format,
      VkCommandBuffer& commandBuffer,
      const VkCommandPool& commandPool,
      const VkQueue& queue);
  void useSwapchainImages(CE::Swapchain& swapchain,
      VkCommandBuffer& commandBuffer,
      const VkCommandPool& commandPool,
      const VkQueue& queue);
  void copyFromSwapchainImage(CE::Swapchain& swapchainImage,
      VkCommandBuffer& commandBuffer,
      const VkCommandPool& commandPool,
      const VkQueue& queue) {
      VkImageCopy copyRegion{};
      copyRegion.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
      copyRegion.srcSubresource.mipLevel = 0;
      copyRegion.srcSubresource.baseArrayLayer = 0;
      copyRegion.srcSubresource.layerCount = 1;
      copyRegion.srcOffset = { 0, 0, 0 };

      copyRegion.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
      copyRegion.dstSubresource.mipLevel = 0;
      copyRegion.dstSubresource.baseArrayLayer = 0;
      copyRegion.dstSubresource.layerCount = 1;
      copyRegion.dstOffset = { 0, 0, 0 };

      copyRegion.extent.width = swapchainImage.extent.width;
      copyRegion.extent.height = swapchainImage.extent.height;
      copyRegion.extent.depth = 1;

      vkCmdCopyImage(commandBuffer, swapchainImage.images[0].image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
          image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &copyRegion);
  }

  static const VkFormat findDepthFormat();

 protected:
  static const VkFormat findSupportedFormat(
      const std::vector<VkFormat>& candidates,
      const VkImageTiling tiling,
      const VkFormatFeatureFlags& features);

 private:
  void destroyVulkanImages() const;
};

class SynchronizationObjects {
 public:
  SynchronizationObjects() = default;
  ~SynchronizationObjects() { destroy(); };

  std::array<VkSemaphore, MAX_FRAMES_IN_FLIGHT> imageAvailableSemaphores{};
  std::array<VkSemaphore, MAX_FRAMES_IN_FLIGHT> renderFinishedSemaphores{};
  std::array<VkSemaphore, MAX_FRAMES_IN_FLIGHT> computeFinishedSemaphores{};
  std::array<VkFence, MAX_FRAMES_IN_FLIGHT> graphicsInFlightFences{};
  std::array<VkFence, MAX_FRAMES_IN_FLIGHT> computeInFlightFences{};
  uint32_t currentFrame = 0;

 protected:
  void create();

 private:
  void destroy() const;
};

class Swapchain {
 public:
  VkSwapchainKHR swapchain{};
  VkExtent2D extent{};
  VkFormat imageFormat{};
  std::array<CE::Image, MAX_FRAMES_IN_FLIGHT> images{};
  std::array<VkFramebuffer, MAX_FRAMES_IN_FLIGHT> framebuffers{};

  struct SupportDetails {
    VkSurfaceCapabilitiesKHR capabilities{};
    std::vector<VkSurfaceFormatKHR> formats{};
    std::vector<VkPresentModeKHR> presentModes{};
  } supportDetails{};

  Swapchain() = default;
  virtual ~Swapchain() { destroy(); };
  const SupportDetails checkSupport(const VkPhysicalDevice& physicalDevice,
                                    const VkSurfaceKHR& surface);

 protected:
  void create(const VkSurfaceKHR& surface, const Queues& queues);
  void recreate(const VkSurfaceKHR& surface,
                const Queues& queues,
                SynchronizationObjects& syncObjects);

 private:
  void destroy();
  const VkSurfaceFormatKHR pickSurfaceFormat(
      const std::vector<VkSurfaceFormatKHR>& availableFormats) const;
  const VkPresentModeKHR pickPresentMode(
      const std::vector<VkPresentModeKHR>& availablePresentModes) const;
  const VkExtent2D pickExtent(
      GLFWwindow* window,
      const VkSurfaceCapabilitiesKHR& capabilities) const;
  const uint32_t getImageCount(
      const Swapchain::SupportDetails& swapchainSupport) const;
};

// Resources
class Descriptor {
 public:
  static std::array<VkDescriptorSet, MAX_FRAMES_IN_FLIGHT> sets;
  static VkDescriptorSetLayout setLayout;
  static std::array<VkDescriptorSetLayoutBinding, NUM_DESCRIPTORS>
      setLayoutBindings;
  static std::array<std::array<VkWriteDescriptorSet, NUM_DESCRIPTORS>,
                    MAX_FRAMES_IN_FLIGHT>
      descriptorWrites;

  Descriptor() = default;
  virtual ~Descriptor();
  static void createSetLayout(
      const std::array<VkDescriptorSetLayoutBinding, NUM_DESCRIPTORS>&
          layoutBindings);
  static void createPool();
  static void allocateSets();
  static void updateSets(
      const std::array<VkDescriptorSet, MAX_FRAMES_IN_FLIGHT>& sets,
      std::array<std::array<VkWriteDescriptorSet, NUM_DESCRIPTORS>,
                 MAX_FRAMES_IN_FLIGHT>& descriptorWrites);

 protected:
  size_t myIndex{0};
  static size_t writeIndex;
  static VkDescriptorPool pool;
  VkDescriptorPoolSize poolSize{};
  static std::vector<VkDescriptorPoolSize> poolSizes;
  VkDescriptorSetLayoutBinding setLayoutBinding{};
  struct DescriptorInformation {
    std::variant<VkDescriptorBufferInfo, VkDescriptorImageInfo> previousFrame{};
    std::variant<VkDescriptorBufferInfo, VkDescriptorImageInfo> currentFrame{};
  } info;
};

struct PushConstants {
  VkShaderStageFlags shaderStage{};
  uint32_t count{};
  uint32_t offset{};
  uint32_t size{};
  std::array<uint64_t, 32> data{};

  PushConstants() = default;
  virtual ~PushConstants() = default;
  void setData(const uint64_t& data);
};

// Pipelines
class PipelineLayout {
 public:
  VkPipelineLayout layout{};

  PipelineLayout() = default;
  virtual ~PipelineLayout();
  void createLayout(const VkDescriptorSetLayout& setLayout);
  void createLayout(const VkDescriptorSetLayout& setLayout,
                    const PushConstants& _pushConstants);
};

class RenderPass {
 public:
  VkRenderPass renderPass{};

  RenderPass() = default;
  virtual ~RenderPass();
  void create(VkSampleCountFlagBits msaaImageSamples,
              VkFormat swapchainImageFormat);
  void createFramebuffers(CE::Swapchain& swapchain,
                          const VkImageView& msaaView,
                          const VkImageView& depthView) const;
};

class PipelinesConfiguration {
 public:
#define PIPELINE_OBJECTS \
  VkPipeline pipeline{}; \
  std::vector<std::string> shaders{};

  struct Graphics {
    PIPELINE_OBJECTS
    std::vector<VkVertexInputAttributeDescription> vertexAttributes{};
    std::vector<VkVertexInputBindingDescription> vertexBindings{};
  };
  struct Compute {
    PIPELINE_OBJECTS
    std::array<uint32_t, 3> workGroups{};
  };
#undef PIPELINE_OBJECTS

  std::vector<VkShaderModule> shaderModules{};
  const std::string shaderDir = "shaders/";
  std::unordered_map<std::string, std::variant<Graphics, Compute>>
      pipelineMap{};

  PipelinesConfiguration() = default;
  virtual ~PipelinesConfiguration();
  void createPipelines(VkRenderPass& renderPass,
                       const VkPipelineLayout& graphicsLayout,
                       const VkPipelineLayout& computeLayout,
                       VkSampleCountFlagBits& msaaSamples);
  const std::vector<std::string>& getPipelineShadersByName(
      const std::string& name);
  VkPipeline& getPipelineObjectByName(const std::string& name);
  const std::array<uint32_t, 3>& getWorkGroupsByName(const std::string& name);

 protected:
  void compileShaders();

 private:
  bool setShaderStages(
      const std::string& pipelineName,
      std::vector<VkPipelineShaderStageCreateInfo>& shaderStages);
  std::vector<char> readShaderFile(const std::string& filename);
  VkPipelineShaderStageCreateInfo createShaderModules(
      VkShaderStageFlagBits shaderStage,
      std::string shaderName);
  void destroyShaderModules();
};

template <typename Checkresult, typename... Args>
static void VULKAN_RESULT(Checkresult vkResult, Args&&... args);

static const uint32_t findMemoryType(const uint32_t typeFilter,
                                     const VkMemoryPropertyFlags properties);

// Pipeline Presets
constexpr static inline VkPipelineRasterizationStateCreateInfo
    rasterizationCullBackBit{
        .sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
        .depthClampEnable = VK_TRUE,
        .rasterizerDiscardEnable = VK_FALSE,
        .polygonMode = VK_POLYGON_MODE_FILL,
        .cullMode = VK_CULL_MODE_BACK_BIT,
        .frontFace = VK_FRONT_FACE_CLOCKWISE,
        .depthBiasEnable = VK_TRUE,
        .depthBiasConstantFactor = 0.1f,
        .depthBiasClamp = 0.01f,
        .depthBiasSlopeFactor = 0.02f,
        .lineWidth = 1.0f};
constexpr static inline VkPipelineInputAssemblyStateCreateInfo
    inputAssemblyStateTriangleList{
        .sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
        .topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
        .primitiveRestartEnable = VK_FALSE};
constexpr static inline VkPipelineVertexInputStateCreateInfo
    vertexInputStateDefault{
        .sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .vertexBindingDescriptionCount = 0,
        .pVertexBindingDescriptions = nullptr,
        .vertexAttributeDescriptionCount = 0,
        .pVertexAttributeDescriptions = nullptr};
constexpr static inline VkPipelineMultisampleStateCreateInfo
    multisampleStateDefault{
        .sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
        .rasterizationSamples = VK_SAMPLE_COUNT_1_BIT,
        .sampleShadingEnable = VK_TRUE,
        .minSampleShading = 1.0f};
constexpr static inline VkPipelineDepthStencilStateCreateInfo
    depthStencilStateDefault{
        .sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
        .depthTestEnable = VK_TRUE,
        .depthWriteEnable = VK_TRUE,
        .depthCompareOp = VK_COMPARE_OP_LESS,
        .depthBoundsTestEnable = VK_FALSE,
        .stencilTestEnable = VK_FALSE};
constexpr static inline VkPipelineColorBlendAttachmentState
    colorBlendAttachmentStateFalse{
        .blendEnable = VK_FALSE,
        .srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA,
        .dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
        .colorBlendOp = VK_BLEND_OP_ADD,
        .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
        .dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO,
        .alphaBlendOp = VK_BLEND_OP_ADD,
        .colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT |
                          VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT};
constexpr static inline VkPipelineColorBlendAttachmentState
    colorBlendAttachmentStateMultiply{
        .blendEnable = VK_TRUE,
        .srcColorBlendFactor = VK_BLEND_FACTOR_DST_COLOR,
        .dstColorBlendFactor = VK_BLEND_FACTOR_ZERO,
        .colorBlendOp = VK_BLEND_OP_ADD,
        .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE,
        .dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO,
        .alphaBlendOp = VK_BLEND_OP_ADD,
        .colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT |
                          VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT};
constexpr static inline VkPipelineColorBlendAttachmentState
    colorBlendAttachmentStateAdd{
        .blendEnable = VK_TRUE,
        .srcColorBlendFactor = VK_BLEND_FACTOR_ONE,
        .dstColorBlendFactor = VK_BLEND_FACTOR_ONE,
        .colorBlendOp = VK_BLEND_OP_ADD,
        .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE,
        .dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE,
        .alphaBlendOp = VK_BLEND_OP_ADD,
        .colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT |
                          VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT};
constexpr static inline VkPipelineColorBlendAttachmentState
    colorBlendAttachmentStateAverage{
        .blendEnable = VK_TRUE,
        .srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA,
        .dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
        .colorBlendOp = VK_BLEND_OP_ADD,
        .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE,
        .dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE,
        .alphaBlendOp = VK_BLEND_OP_ADD,
        .colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT |
                          VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT};
constexpr static inline VkPipelineColorBlendAttachmentState
    colorBlendAttachmentStateSubtract{
        .blendEnable = VK_TRUE,
        .srcColorBlendFactor = VK_BLEND_FACTOR_ONE,
        .dstColorBlendFactor = VK_BLEND_FACTOR_ONE,
        .colorBlendOp = VK_BLEND_OP_REVERSE_SUBTRACT,
        .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE,
        .dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE,
        .alphaBlendOp = VK_BLEND_OP_ADD,
        .colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT |
                          VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT};
constexpr static inline VkPipelineColorBlendAttachmentState
    colorBlendAttachmentStateScreen{
        .blendEnable = VK_TRUE,
        .srcColorBlendFactor = VK_BLEND_FACTOR_ONE,
        .dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
        .colorBlendOp = VK_BLEND_OP_ADD,
        .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE,
        .dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
        .alphaBlendOp = VK_BLEND_OP_ADD,
        .colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT |
                          VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT};
constexpr static inline VkPipelineColorBlendStateCreateInfo
    colorBlendStateDefault{
        .sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .logicOpEnable = VK_FALSE,
        .logicOp = VK_LOGIC_OP_COPY,
        .attachmentCount = 1,
        .pAttachments = nullptr,
        .blendConstants = {0.0f, 0.0f, 0.0f, 0.0f}};
constexpr static inline VkPipelineViewportStateCreateInfo viewportStateDefault{
    .sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
    .viewportCount = 1,
    .scissorCount = 1};
constexpr static inline VkDynamicState dynamicStates[] = {
    VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR};
constexpr static inline VkPipelineDynamicStateCreateInfo dynamicStateDefault{
    .sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
    .dynamicStateCount = sizeof(dynamicStates) / sizeof(dynamicStates[0]),
    .pDynamicStates = dynamicStates};
constexpr static inline VkPipelineLayoutCreateInfo layoutDefault{
    .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
    .setLayoutCount = 1,
    .pSetLayouts = nullptr};
const static inline uint32_t tessellationTopologyTriangle = 3;
constexpr static inline VkPipelineTessellationStateCreateInfo
    tessellationStateDefault{
        .sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
        .pNext = nullptr,
        .flags = 0,
        .patchControlPoints = tessellationTopologyTriangle};
};  // namespace CE

template <typename Checkresult, typename... Args>
void CE::VULKAN_RESULT(Checkresult vkResult, Args&&... args) {
  using ObjectType = std::remove_pointer_t<std::decay_t<Checkresult>>;
  std::string objectName = typeid(ObjectType).name();

  VkResult result = vkResult(std::forward<Args>(args)...);
  if (result != VK_SUCCESS) {
    throw std::runtime_error("\n!ERROR! result != VK_SUCCESS " + objectName +
                             "!");
  }
}

#pragma once
// Namespaces
#include "Library.h"
#include "Log.h"

// Singletons
#include "Window.h"

// Engine modules
#include "BaseClasses.h"
#include "Mechanics.h"
#include "Pipelines.h"
#include "Resources.h"

class CapitalEngine {
 public:
  CapitalEngine();
  ~CapitalEngine();

  void mainLoop();

 private:
  VulkanMechanics mechanics;
  Resources resources;
  Pipelines pipelines;

  void drawFrame();
};

#pragma once
#include <vulkan/vulkan.h>

#define GLM_FORCE_RADIANS
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#define GLM_ENABLE_EXPERIMENTAL
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/quaternion.hpp>
#include <glm/gtx/hash.hpp>

#include "BaseClasses.h"

#include <string>
#include <vector>

const enum ORIENTATION_ORDER { ROTATE_SCALE_TRANSLATE, ROTATE_TRANSLATE_SCALE };

class Vertex {
 public:
  glm::vec3 instancePosition{};
  glm::vec3 vertexPosition{};
  glm::vec3 normal{};
  glm::vec3 color{};
  glm::vec2 textureCoordinates{};

  static std::vector<VkVertexInputBindingDescription> getBindingDescription();
  static std::vector<VkVertexInputAttributeDescription>
  getAttributeDescription();

  bool operator==(const Vertex& other) const {
    return vertexPosition == other.vertexPosition && color == other.color &&
           textureCoordinates == other.textureCoordinates &&
           normal == other.normal;
  }
};

class Geometry : public Vertex {
 public:
  Geometry(const std::string& modelName = "");
  virtual ~Geometry() = default;
  std::vector<Vertex> allVertices{};
  std::vector<Vertex> uniqueVertices{};
  std::vector<uint32_t> indices{};

  CE::Buffer vertexBuffer;
  CE::Buffer indexBuffer;

  void addVertexPosition(const glm::vec3& position);
  static std::vector<uint32_t> createGridPolygons(
      const std::vector<uint32_t>& vertices,
      uint32_t gridWidth);

 protected:
  void createVertexBuffer(VkCommandBuffer& commandBuffer,
                          const VkCommandPool& commandPool,
                          const VkQueue& queue,
                          const std::vector<Vertex>& vertices);

  void createIndexBuffer(VkCommandBuffer& commandBuffer,
                         const VkCommandPool& commandPool,
                         const VkQueue& queue,
                         const std::vector<uint32_t>& indices);

 private:
  void loadModel(const std::string& modelName, Geometry& geometry);
  void transformModel(std::vector<Vertex>& vertices,
                      ORIENTATION_ORDER order,
                      const glm::vec3& degrees = glm::vec3(0.0f),
                      const glm::vec3& translationDistance = glm::vec3(0.0f),
                      float scale = 1.0f);
};

#pragma once
#include <glm/glm.hpp>

#include <string>
#include <vector>

struct vec2_uint_fast16_t {
  uint_fast16_t x;
  uint_fast16_t y;
};

namespace Lib {
std::vector<float> generateRandomValues(int amount, float min, float max);

double lowFrequencyOscillator(double frequency);
glm::vec2 smoothstep(const glm::vec2& xy);

std::string upperToLowerCase(std::string string);

// Cross platform functions
std::string path(const std::string& linuxPath);
std::string ifShaderCompile(std::string linuxPath);
}  // namespace Lib

#pragma once
#include <vulkan/vulkan.h>

#include <fstream>
#include <iostream>
#include <stdexcept>
#include <unordered_map>
#include <vector>

#define STRINGIFICATION(x) #x

namespace Log {
const enum LogLevel { LOG_OFF, LOG_MINIMIAL, LOG_MODERATE, LOG_DETAILED };
static uint8_t logLevel = LOG_MINIMIAL;
extern std::ofstream logFile;
extern std::string previousTime;

struct Style {
  static std::string charLeader;
  static std::string indentSize;
  static std::string headerGuard;
  static int columnCount;
  static int columnCountOffset;
};
void logTitle();
void logFooter();

template <class T, class... Ts>
void text(const T& first, const Ts&... inputs);
bool skipLogging(uint8_t logLevel, std::string icon);
void measureElapsedTime();

std::string getBufferUsageString(const VkBufferUsageFlags& usage);
std::string getMemoryPropertyString(const VkMemoryPropertyFlags& properties);
std::string getDescriptorTypeString(const VkDescriptorType& type);
std::string getShaderStageString(const VkShaderStageFlags& flags);
std::string getSampleCountString(const VkSampleCountFlags& sampleCount);
std::string getImageUsageString(const VkImageUsageFlags& usage);

std::string returnDateAndTime();
};  // namespace Log

template <class T, class... Ts>
void Log::text(const T& first, const Ts&... inputs) {
  if (Log::skipLogging(logLevel, first)) {
    return;
  }

  std::string currentTime = returnDateAndTime();
  if (currentTime != previousTime) {
    std::cout << ' ' << currentTime;
    logFile << ' ' << currentTime;
  } else {
    std::string padding(
        static_cast<size_t>(Style::columnCount) + Style::columnCountOffset,
        ' ');
    std::cout << padding;
    logFile << padding;
  }
  if constexpr (std::is_same_v<T, std::vector<int>>) {
    static int elementCount = 0;
    std::cout << ' ' << Style::charLeader << ' ';
    logFile << ' ' << Style::charLeader << ' ';
    for (const auto& element : first) {
      if (elementCount % Style::columnCount == 0 && elementCount != 0) {
        std::string spaces(
            static_cast<size_t>(Style::columnCount) + Style::columnCountOffset,
            ' ');
        std::cout << '\n' << ' ' << spaces << Style::charLeader << ' ';
        logFile << '\n' << ' ' << spaces << Style::charLeader << ' ';
        elementCount = 0;
      }
      std::cout << element << ' ';
      logFile << element << ' ';
      elementCount++;
    }
    std::cout << '\n';
    logFile << '\n';
  } else {
    std::cout << ' ' << first;
    logFile << ' ' << first;
    ((std::cout << ' ' << inputs, logFile << ' ' << inputs), ...);
    std::cout << '\n';
    logFile << '\n';
  }
  previousTime = currentTime;
}

#pragma once
#include "CapitalEngine.h"
#include "Pipelines.h"
#include "Resources.h"

class VulkanMechanics {
 public:
  VulkanMechanics();
  ~VulkanMechanics();

  CE::InitializeVulkan initVulkan{};
  CE::Queues queues{};

  struct Device : public CE::Device {
    Device(const CE::InitializeVulkan& initVulkan,
           CE::Queues& queues,
           CE::Swapchain& swapchain) {
      CE::Device::baseDevice = this;

      features.tessellationShader = VK_TRUE;
      features.sampleRateShading = VK_TRUE;
      features.depthClamp = VK_TRUE;
      features.depthBiasClamp = VK_TRUE;
      features.fillModeNonSolid = VK_TRUE;
      features.wideLines = VK_TRUE;
      features.samplerAnisotropy = VK_TRUE;
      features.shaderInt64 = VK_TRUE;

      pickPhysicalDevice(initVulkan, queues, swapchain);
      createLogicalDevice(initVulkan, queues);
    };
    ~Device() { destroyDevice(); }
  } mainDevice;

  struct SynchronizationObjects : public CE::SynchronizationObjects {
    SynchronizationObjects() { create(); }
  } syncObjects;

  struct Swapchain : public CE::Swapchain {
    Swapchain(const VkSurfaceKHR& surface, const CE::Queues& queues) {
      create(surface, queues);
    }
    void recreate(const VkSurfaceKHR& surface,
                  const CE::Queues& queues,
                  SynchronizationObjects& syncObjects,
                  Pipelines& pipelines,
                  Resources& resources);
  } swapchain;
};

#pragma once
#include <glm/glm.hpp>

#include "Mechanics.h"
#include "Resources.h"

class Pipelines {
 public:
  Pipelines(VulkanMechanics& mechanics, Resources& resources);
  ~Pipelines();

  struct ComputeLayout : public CE::PipelineLayout {
    ComputeLayout(CE::PushConstants& pushConstants) {
      createLayout(CE::Descriptor::setLayout, pushConstants);
    }
  } compute;

  struct GraphicsLayout : public CE::PipelineLayout {
    GraphicsLayout() { createLayout(CE::Descriptor::setLayout); }
  } graphics;

  struct Render : public CE::RenderPass {
    Render(CE::Swapchain& swapchain,
           const CE::Image& msaaImage,
           const VkImageView& depthView) {
      create(msaaImage.info.samples, swapchain.imageFormat);
      createFramebuffers(swapchain, msaaImage.view, depthView);
    }
  } render;

  struct Configuration : public CE::PipelinesConfiguration {
    Configuration(VkRenderPass& renderPass,
                  const VkPipelineLayout& graphicsLayout,
                  const VkPipelineLayout& computeLayout,
                  VkSampleCountFlagBits& msaaSamples,
                  const vec2_uint_fast16_t gridSize) {
      pipelineMap["Engine"] = Compute{
          .shaders = {"Comp"},
          .workGroups = {static_cast<uint32_t>(gridSize.x + 31) / 32,
                         static_cast<uint32_t>(gridSize.y + 31) / 32, 1}};
      pipelineMap["Cells"] =
          Graphics{.shaders = {"Vert", "Frag"},
                   .vertexAttributes = World::Cell::getAttributeDescription(),
                   .vertexBindings = World::Cell::getBindingDescription()};
      pipelineMap["Landscape"] =
          Graphics{.shaders = {"Vert", "Frag"},
                   .vertexAttributes = World::Grid::getAttributeDescription(),
                   .vertexBindings = World::Grid::getBindingDescription()};
      pipelineMap["LandscapeWireFrame"] = Graphics{
          .shaders = {"LandscapeVert", "Tesc", "Tese", "LandscapeFrag"},
          .vertexAttributes = World::Grid::getAttributeDescription(),
          .vertexBindings = World::Grid::getBindingDescription()};
      pipelineMap["Texture"] = Graphics{
          .shaders = {"Vert", "Frag"},
          .vertexAttributes = World::Rectangle::getAttributeDescription(),
          .vertexBindings = World::Rectangle::getBindingDescription()};
      pipelineMap["Water"] = Graphics{
          .shaders = {"Vert", "Frag"},
          .vertexAttributes = World::Rectangle::getAttributeDescription(),
          .vertexBindings = World::Rectangle::getBindingDescription()};
      pipelineMap["PostFX"] = Compute{
          .shaders = {"Comp"},
          .workGroups = {
              static_cast<uint32_t>(Window::get().display.width + 7) / 8,
              static_cast<uint32_t>(Window::get().display.height + 7) / 8, 1}};

      compileShaders();
      createPipelines(renderPass, graphicsLayout, computeLayout, msaaSamples);
    }
  } config;
};

#pragma once
#include "vulkan/vulkan.h"

#include "Mechanics.h"
#include "Pipelines.h"
#include "World.h"

#include <array>
#include <cstring>
#include <string>
#include <utility>
#include <variant>
#include <vector>

class Resources {
 public:
  Resources(VulkanMechanics& mechanics, Pipelines& pipelines);
  ~Resources();

  struct Commands : public CE::CommandBuffers {
    Commands(const CE::Queues::FamilyIndices& familyIndices);
    void recordComputeCommandBuffer(Resources& resources,
                                    Pipelines& pipelines,
                                    const uint32_t imageIndex) override;
    void recordGraphicsCommandBuffer(CE::Swapchain& swapchain,
                                     Resources& resources,
                                     Pipelines& pipelines,
                                     const uint32_t imageIndex) override;
  } commands;

  World world;

  struct DepthImage : public CE::Image {
    DepthImage(const VkExtent2D extent, const VkFormat format);
  } depthImage;

  struct MultisamplingImage : public CE::Image {
    MultisamplingImage(const VkExtent2D extent, const VkFormat format);
  } msaaImage;

  class UniformBuffer : public CE::Descriptor {
   public:
    UniformBuffer();
    void update(World& world, const VkExtent2D extent);

   private:
    CE::Buffer buffer;
    World::UniformBufferObject object;
    void createBuffer();
    void createDescriptorWrite();
  } uniform;

  class StorageBuffer : public CE::Descriptor {
   public:
    CE::Buffer bufferIn;
    CE::Buffer bufferOut;
    StorageBuffer(VkCommandBuffer& commandBuffer,
                  const VkCommandPool& commandPool,
                  const VkQueue& queue,
                  const auto& object,
                  const size_t quantity);

   private:
    void create(VkCommandBuffer& commandBuffer,
                const VkCommandPool& commandPool,
                const VkQueue& queue,
                const auto& object,
                const size_t quantity);
    void createDescriptorWrite(const size_t quantity);
  } shaderStorage;

  class ImageSampler : public CE::Descriptor {
   public:
    ImageSampler(VkCommandBuffer& commandBuffer,
                 VkCommandPool& commandPool,
                 const VkQueue& queue, CE::Swapchain& swapchain);

   private:
    void createDescriptorWrite();
    struct TextureImage : public CE::Image {
      TextureImage() { path = Lib::path("assets/Avatar.PNG"); }
    } textureImage;
  } sampler;

  class StorageImage : public CE::Descriptor {
   public:
    StorageImage(std::array<CE::Image, MAX_FRAMES_IN_FLIGHT>& images);
    void createDescriptorWrite(
        std::array<CE::Image, MAX_FRAMES_IN_FLIGHT>& images);
  } storageImage;

  struct PushConstants : public CE::PushConstants {
    PushConstants() {
      shaderStage = VK_SHADER_STAGE_COMPUTE_BIT;
      count = 1;
      offset = 0;
      size = 128;
      data.fill(0);
    }
  } pushConstants;
};

#include "Library.h"

#include <vector>

class Terrain {
 public:
  struct Config {
    vec2_uint_fast16_t dimensions;
    float roughness;
    int octaves;
    float scale;
    float amplitude;
    float exponent;
    float frequency;
    float heightOffset;
  } config;

  Terrain(const Config& config);
  virtual ~Terrain() = default;

  std::vector<float> generatePerlinGrid();
  float linearInterpolationFunction(float a, float b, float t);
};

#include <cstdint>

class Timer {
 public:
  Timer(float initSpeed);
  virtual ~Timer() = default;

  float speed{1.0f};
  uint64_t passedHours{0};
  float dayFraction{0.0f};

  void run();

 private:
  const int HOURS_PER_DAY{24};
  const float TARGET_DURATION{1.0f / (speed / HOURS_PER_DAY)};
  const float TRIGGER_DELAY_UNDER_SPEED = 100.0f;
};

#pragma once
#include <vulkan/vulkan.h>

#include <string>
#include <vector>

class ValidationLayers {
 public:
  ValidationLayers();
  ~ValidationLayers();

  VkDebugUtilsMessengerEXT debugMessenger;
  const std::vector<const char*> validation;

#ifdef NDEBUG
  const bool enableValidationLayers = false;
#else
  const bool enableValidationLayers = true;
#endif

  void setupDebugMessenger(VkInstance instance);
  void populateDebugMessengerCreateInfo(
      VkDebugUtilsMessengerCreateInfoEXT& createInfo);
  bool checkValidationLayerSupport();
  void DestroyDebugUtilsMessengerEXT(VkInstance instance,
                                     VkDebugUtilsMessengerEXT debugMessenger,
                                     const VkAllocationCallbacks* pAllocator);

 private:
  void static logValidationMessage(const std::string& string,
                                   const std::string& excludeError);
  VkResult CreateDebugUtilsMessengerEXT(
      VkInstance instance,
      const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
      const VkAllocationCallbacks* pAllocator,
      VkDebugUtilsMessengerEXT* pDebugMessenger);

  static VKAPI_ATTR VkBool32 VKAPI_CALL
  debugCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
                VkDebugUtilsMessageTypeFlagsEXT messageType,
                const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,
                void* pUserData) {
    const std::string debugMessage = pCallbackData->pMessage;
    logValidationMessage(debugMessage, "Epic Games");
    return VK_FALSE;
  }
};

#pragma once
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>

#include <array>

class Window {
 public:
  Window(const Window&) = delete;
  static Window& get() { return mainWindow; }

  GLFWwindow* window;
  bool framebufferResized;

  struct DisplayConfiguration {
    const char* title{"GENERATIONS"};
    uint16_t width = 3800;
    uint16_t height = 1080;
  } display;

  struct Mouse {
    float pressDelay = 0.18f;
    float speed = 0.5f;

    struct Button {
      glm::vec2 position;
    };
    std::array<Button, 3> buttonClick;
    std::array<Button, 3> buttonDown;
    std::array<Button, 3> previousButtonDown;
  } mouse;

  void setMouse();

 private:
  Window();
  ~Window();

  void initWindow();
  static void windowResize(GLFWwindow* win, int width, int height);

  static Window mainWindow;
};

#pragma once
#include "Geometry.h"
#include "Library.h"
#include "Timer.h"

#include <algorithm>
#include <array>
#include <numeric>
#include <utility>
#include <vector>

class Timer;

class World {
 public:
  World(VkCommandBuffer& commandBuffer,
        const VkCommandPool& commandPool,
        const VkQueue& queue);
  ~World();

  float speed = 25.0f;
  Timer time{speed};

  struct alignas(16) Cell {
    glm::vec4 instancePosition{};
    glm::vec4 vertexPosition{};
    glm::vec4 normal{};
    glm::vec4 color{};
    glm::ivec4 states{};

    static std::vector<VkVertexInputBindingDescription> getBindingDescription();
    static std::vector<VkVertexInputAttributeDescription>
    getAttributeDescription();
  };

  struct Grid : public Geometry {
    vec2_uint_fast16_t size = {100, 100};
    const uint_fast32_t initialAliveCells = 5000;
    const size_t pointCount{size.x * size.y};

    std::vector<uint32_t> pointIDs = std::vector<uint32_t>(pointCount);
    std::vector<glm::vec3> coorindates = std::vector<glm::vec3>(pointCount);
    std::vector<World::Cell> cells = std::vector<World::Cell>(pointCount);
    const float initialCellSize{0.5f};

    Grid(VkCommandBuffer& commandBuffer,
         const VkCommandPool& commandPool,
         const VkQueue& queue);
    static std::vector<VkVertexInputAttributeDescription>
    getAttributeDescription();

   private:
    std::vector<uint_fast32_t> setCellsAliveRandomly(
        uint_fast32_t numberOfCells);
  } grid;

  struct Rectangle : public Geometry {
    Rectangle(VkCommandBuffer& commandBuffer,
              const VkCommandPool& commandPool,
              const VkQueue& queue);
  } rectangle;

  struct Cube : public Geometry {
    Cube(VkCommandBuffer& commandBuffer,
         const VkCommandPool& commandPool,
         const VkQueue& queue);
  } cube;

  struct UniformBufferObject {
    glm::vec4 light{};
    glm::ivec2 gridXY{};
    float waterThreshold{};
    float cellSize{};
    alignas(16) glm::mat4 model{};
    alignas(16) glm::mat4 view{};
    alignas(16) glm::mat4 projection{};
  };

  struct Light {
    glm::vec4 position{0.0f, 20.0f, 20.0f, 0.0f};
  } light;

  class Camera {
   public:
    float zoomSpeed = 0.5f;
    float panningSpeed = 1.2f;
    const float fieldOfView = 40.0f;
    const float nearClipping = 0.1f;
    const float farClipping = 100.0f;
    glm::vec3 position{0.0f, 0.0f, 30.0f};
    glm::vec3 front{0.0f, 0.0f, -1.0f};
    glm::vec3 up{0.0f, -1.0f, 0.0f};

    glm::mat4 setModel();
    glm::mat4 setView();
    glm::mat4 setProjection(const VkExtent2D& swapchainExtent);

   private:
    void update();
  } camera;
};

// float getForwardMovement(const glm::vec2& leftButtonDelta);


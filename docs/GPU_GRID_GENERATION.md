# GPU Grid Generation - Staging Shader Implementation

## Overview

This document describes the GPU-based grid generation system using a compute shader staging approach. The implementation moves grid vertex generation from CPU to GPU, following the project's GPU-first architecture principles.

## Architecture

### Current State (CPU-based)
- Grid vertices generated in `World::Grid` constructor (CPU)
- Flat vertices uploaded to GPU vertex buffers
- Landscape.vert shader applies `terrain_height()` function dynamically every frame

### New State (GPU-based Staging)
- Grid vertices generated by `GridGeneration.comp` compute shader (GPU)
- Terrain height pre-computed and stored in GPU buffer
- One-time execution at initialization (staging approach)
- Vertices available for rendering without per-frame height calculation

## Components

### 1. GridGeneration.comp Shader
**Location**: `shaders/GridGeneration.comp`

**Purpose**: Generate grid vertex positions with terrain height on GPU

**Key Features**:
- Compute shader with 32x32 work groups
- Reuses `terrain_height()` function from Landscape.vert
- Outputs to storage buffer (binding 5)
- Vertex format: vec3 position + float padding (16 bytes aligned)

**Bindings**:
- Binding 0: Uniform buffer (shared UBO with terrain parameters)
- Binding 5: Storage buffer (output grid vertices)

**Push Constants**:
- `renderGridWidth`: Width of render grid
- `renderGridHeight`: Height of render grid  
- `renderSubdivisions`: Subdivision factor for mesh density

### 2. GridVertexBuffer Class
**Location**: `src/render/Resources.h/cpp`

**Purpose**: Manage GPU storage buffer for grid vertices

**Features**:
- Descriptor binding 5 (VK_DESCRIPTOR_TYPE_STORAGE_BUFFER)
- Accessible from compute and vertex shaders
- Device-local memory for optimal GPU access
- Size: 16 bytes per vertex (vec3 + padding)

### 3. Pipeline Definition
**Location**: `src/implementation/ImplementationSpec.cpp`

**Configuration**:
```cpp
spec.pipelines["GridGeneration"] = CE::Runtime::PipelineDefinition{
  .is_compute = true,
  .shaders = {"GridGenerationComp"},
  .work_groups = {0, 0, 0},  // Calculated dynamically
};
```

## Usage

### Current Status
The infrastructure is in place but not yet integrated into the main execution loop. The shader demonstrates the concept but requires additional integration to be used in rendering.

### Integration Options

**Option 1: One-Time Initialization**
Run the compute shader once during resource initialization:
- Dispatch GridGeneration shader during setup
- Use generated vertices for all subsequent frames
- Update Landscape.vert to skip dynamic terrain height calculation

**Option 2: Conditional Execution**
Add logic to run the shader only once:
- Include in pre_graphics_compute pipeline
- Add frame counter to skip after first execution
- Useful for debugging and validation

**Option 3: Configurable Generation**
Make grid generation method configurable:
- Environment variable to choose CPU vs GPU generation
- Allows A/B testing and validation
- Maintains backward compatibility

## Benefits of GPU Staging Approach

1. **GPU-First Architecture**: Aligns with project goals of GPU-centric design
2. **Performance**: Eliminates per-frame terrain height calculations
3. **Scalability**: Handles larger grids without CPU bottleneck
4. **Consistency**: Same noise functions used in generation and rendering
5. **Flexibility**: Easy to modify terrain parameters in compute shader

## Current Limitations

1. **Not Yet Active**: Shader exists but not dispatched in execution loop
2. **Double Height Application**: Would need to update Landscape.vert to use pre-computed heights
3. **No Fallback**: CPU generation still used; GPU generation is additional infrastructure
4. **Fixed at Init**: Terrain cannot be dynamically modified without re-dispatch

## Future Work

- [ ] Add dispatch logic to run shader once at initialization
- [ ] Create LandscapeStaged.vert shader that reads from pre-computed buffer
- [ ] Add push constants for dynamic work group calculation
- [ ] Add environment variable to toggle CPU/GPU generation
- [ ] Performance benchmarking vs current approach
- [ ] Support for dynamic terrain regeneration

## Technical Details

### Buffer Layout
```glsl
struct GridVertex {
    vec3 position;    // x, y, z with terrain height applied
    float _padding;   // alignment padding to 16 bytes
};
```

### Work Group Calculation
For a grid of size `renderGridWidth x renderGridHeight`:
- Work groups: `(width + 31) / 32, (height + 31) / 32, 1`
- Each thread processes one vertex
- Bounds checking prevents out-of-range writes

### Terrain Height Function
The shader uses the same `terrain_height()` implementation as Landscape.vert:
- FBM (Fractal Brownian Motion) for broad features
- Ridged FBM for mountains and crags
- Domain warping for natural variation
- Macro-scale sinusoidal modulation

## References

- **Engine.comp**: Reference compute shader structure
- **Landscape.vert**: Terrain height calculation source
- **World.cpp**: CPU grid generation (current implementation)
- **Resources.cpp**: Descriptor and buffer management patterns

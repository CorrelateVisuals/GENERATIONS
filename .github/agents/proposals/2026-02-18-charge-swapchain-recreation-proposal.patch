### PATCH: `src/engine/CapitalEngine.cpp`

#### SEARCH
```cpp
void CapitalEngine::recreate_swapchain() {
  mechanics.swapchain.recreate(mechanics.init_vulkan.surface,
                               mechanics.queues,
                               mechanics.sync_objects,
                               *pipelines,
                               *resources);
}
```

#### REPLACE
```cpp
void CapitalEngine::recreate_swapchain() {
  try {
    Log::text("Recreating swapchain...");
    
    // Ensure all GPU operations are completed before destroying resources
    mechanics.sync_objects.wait_for_idle();

    // Recreate the swapchain and associated resources
    mechanics.swapchain.recreate(
        mechanics.init_vulkan.surface,
        mechanics.queues,
        mechanics.sync_objects,
        *pipelines,
        *resources
    );

    // Update frame context with the new swapchain configuration
    frame_context->update_swapchain(mechanics.swapchain);

    Log::text("Swapchain recreation completed successfully.");
  } catch (const std::exception &e) {
    Log::text("Error during swapchain recreation: ", e.what());
    throw; // Re-throw to ensure proper error handling upstream
  }
}
```

---

### PATCH: `src/engine/Log.cpp`

#### SEARCH
```cpp
std::ofstream Log::log_file("log.txt");
```

#### REPLACE
```cpp
std::ofstream Log::log_file("log.txt");

void Log::log_swapchain_recreation(const std::string &message) {
  text(Log::Style::header_guard);
  text("| SWAPCHAIN RECREATION | " + message);
  text(Log::Style::header_guard);
}
```

---

### PATCH: `src/engine/Log.h`

#### ADD
```cpp
class Log {
  ...
  static void log_swapchain_recreation(const std::string &message);
  ...
};
```

---

### PATCH: `src/vulkan_mechanics/Mechanics.cpp`

#### SEARCH
```cpp
void VulkanMechanics::BaseSwapchain::recreate(const VkSurfaceKHR &surface,
                                          const CE::BaseQueues &queues,
                                          BaseSynchronizationObjects &sync_objects,
                                          Pipelines &pipelines,
                                          VulkanResources &resources) {
  CE::BaseSwapchain::recreate(surface, queues, sync_objects);
  pipelines.config.refresh_dynamic_work_groups(resources.world._grid.size, extent);
    resources.msaa_image.create_resources(CE_MULTISAMPLE_IMAGE, extent, image_format);
    resources.depth_image.create_resources(
      CE_DEPTH_IMAGE, extent, CE::BaseImage::find_depth_format());
  pipelines.render.create_framebuffers(
      *this, resources.msaa_image.view, resources.depth_image.view);

  resources.storage_image.create_descriptor_write(resources.descriptor_interface, images);
  resources.descriptor_interface.update_sets();
}
```

#### REPLACE
```cpp
void VulkanMechanics::BaseSwapchain::recreate(const VkSurfaceKHR &surface,
                                          const CE::BaseQueues &queues,
                                          BaseSynchronizationObjects &sync_objects,
                                          Pipelines &pipelines,
                                          VulkanResources &resources) {
  Log::log_swapchain_recreation("Starting swapchain recreation...");

  // Recreate the base swapchain
  CE::BaseSwapchain::recreate(surface, queues, sync_objects);

  // Refresh pipeline configurations
  pipelines.config.refresh_dynamic_work_groups(resources.world._grid.size, extent);

  // Recreate MSAA and depth resources
  resources.msaa_image.create_resources(CE_MULTISAMPLE_IMAGE, extent, image_format);
  resources.depth_image.create_resources(
      CE_DEPTH_IMAGE, extent, CE::BaseImage::find_depth_format());

  // Recreate framebuffers
  pipelines.render.create_framebuffers(
      *this, resources.msaa_image.view, resources.depth_image.view);

  // Update storage image descriptors
  resources.storage_image.create_descriptor_write(resources.descriptor_interface, images);
  resources.descriptor_interface.update_sets();

  Log::log_swapchain_recreation("Swapchain recreation completed.");
}
```

---

### PATCH: `src/vulkan_pipelines/Pipelines.cpp`

#### SEARCH
```cpp
Pipelines::Pipelines(VulkanMechanics &mechanics, VulkanResources &resources)
    : compute{resources.descriptor_interface, resources.push_constant},
      graphics{resources.descriptor_interface}, render{mechanics.swapchain,
                                                       resources.msaa_image,
                                                       resources.depth_image.view},
      config{render.render_pass,
             graphics.layout,
             compute.layout,
             resources.msaa_image.info.samples,
              resources.world._grid.size,
              mechanics.swapchain.extent} {
  Log::text("{ === }", "constructing Pipelines");
}
```

#### REPLACE
```cpp
Pipelines::Pipelines(VulkanMechanics &mechanics, VulkanResources &resources)
    : compute{resources.descriptor_interface, resources.push_constant},
      graphics{resources.descriptor_interface}, render{mechanics.swapchain,
                                                       resources.msaa_image,
                                                       resources.depth_image.view},
      config{render.render_pass,
             graphics.layout,
             compute.layout,
             resources.msaa_image.info.samples,
              resources.world._grid.size,
              mechanics.swapchain.extent} {
  Log::text("{ === }", "Constructing Pipelines");
}

void Pipelines::update_for_swapchain(const VulkanMechanics &mechanics, VulkanResources &resources) {
  Log::text("{ === }", "Updating Pipelines for new swapchain...");

  // Refresh pipeline configurations
  config.refresh_dynamic_work_groups(resources.world._grid.size, mechanics.swapchain.extent);

  // Recreate framebuffers
  render.create_framebuffers(
      mechanics.swapchain, resources.msaa_image.view, resources.depth_image.view);

  Log::text("{ === }", "Pipelines updated for new swapchain.");
}
```

---

### PATCH: `src/vulkan_pipelines/Pipelines.h`

#### ADD
```cpp
class Pipelines {
  ...
  void update_for_swapchain(const VulkanMechanics &mechanics, VulkanResources &resources);
  ...
};
```

---

### PATCH: `src/vulkan_resources/VulkanResources.cpp`

#### SEARCH
```cpp
        msaa_image{CE_MULTISAMPLE_IMAGE,
                mechanics.swapchain.extent,
            mechanics.swapchain.image_format},
```

#### REPLACE
```cpp
        msaa_image{CE_MULTISAMPLE_IMAGE,
                mechanics.swapchain.extent,
            mechanics.swapchain.image_format},
        depth_image{CE_DEPTH_IMAGE,
                mechanics.swapchain.extent,
                CE::BaseImage::find_depth_format()},
```

---

### PATCH: `src/vulkan_resources/VulkanResources.cpp`

#### ADD
```cpp
void VulkanResources::update_for_swapchain(const VulkanMechanics &mechanics) {
  Log::text("{ /// }", "Updating VulkanResources for new swapchain...");

  // Recreate MSAA and depth resources
  msaa_image.create_resources(CE_MULTISAMPLE_IMAGE, mechanics.swapchain.extent, mechanics.swapchain.image_format);
  depth_image.create_resources(
      CE_DEPTH_IMAGE, mechanics.swapchain.extent, CE::BaseImage::find_depth_format());

  // Update storage image descriptors
  storage_image.create_descriptor_write(descriptor_interface, mechanics.swapchain.images);
  descriptor_interface.update_sets();

  Log::text("{ /// }", "VulkanResources updated for new swapchain.");
}
```

---

### PATCH: `src/vulkan_resources/VulkanResources.h`

#### ADD
```cpp
class VulkanResources {
  ...
  void update_for_swapchain(const VulkanMechanics &mechanics);
  ...
};
```

---

### PATCH: `src/engine/CapitalEngine.cpp`

#### SEARCH
```cpp
void CapitalEngine::recreate_swapchain() {
  try {
    Log::text("Recreating swapchain...");
    
    // Ensure all GPU operations are completed before destroying resources
    mechanics.sync_objects.wait_for_idle();

    // Recreate the swapchain and associated resources
    mechanics.swapchain.recreate(
        mechanics.init_vulkan.surface,
        mechanics.queues,
        mechanics.sync_objects,
        *pipelines,
        *resources
    );

    // Update frame context with the new swapchain configuration
    frame_context->update_swapchain(mechanics.swapchain);

    Log::text("Swapchain recreation completed successfully.");
  } catch (const std::exception &e) {
    Log::text("Error during swapchain recreation: ", e.what());
    throw; // Re-throw to ensure proper error handling upstream
  }
}
```

#### REPLACE
```cpp
void CapitalEngine::recreate_swapchain() {
  try {
    Log::text("Recreating swapchain...");
    
    // Ensure all GPU operations are completed before destroying resources
    mechanics.sync_objects.wait_for_idle();

    // Recreate the swapchain
    mechanics.swapchain.recreate(
        mechanics.init_vulkan.surface,
        mechanics.queues,
        mechanics.sync_objects,
        *pipelines,
        *resources
    );

    // Update Vulkan resources and pipelines
    resources->update_for_swapchain(mechanics);
    pipelines->update_for_swapchain(mechanics, *resources);

    // Update frame context with the new swapchain configuration
    frame_context->update_swapchain(mechanics.swapchain);

    Log::text("Swapchain recreation completed successfully.");
  } catch (const std::exception &e) {
    Log::text("Error during swapchain recreation: ", e.what());
    throw; // Re-throw to ensure proper error handling upstream
  }
}
```

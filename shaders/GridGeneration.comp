#version 450

// Grid Generation Compute Shader
// Generates grid vertex positions with terrain height on GPU
// This is a staging shader - runs once at initialization, not per frame

struct GridVertex {
    vec3 position;    // x, y, z with terrain height applied
    float _padding;   // alignment padding
};

layout(std430, binding = 5) writeonly buffer GridVertexBuffer {
    GridVertex vertices[];
};

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 0) uniform ParameterUBO {
    vec4 light;
    ivec2 gridXY;
    float waterThreshold;
    float cellSize;
    vec4 waterRules;  // x: dead-zone margin, y: shore band width, z: border highlight width, w: absolute height
    mat4 model;
    mat4 view;
    mat4 projection;
} ubo;

layout(push_constant, std430) uniform PushConstants {
    uint renderGridWidth;
    uint renderGridHeight;
    uint renderSubdivisions;
    uint _padding;
} pushConstants;

// Hash and noise functions for procedural terrain generation
// Hash function for procedural noise generation
// Magic numbers chosen for good distribution properties
float hash21(vec2 p) {
    return fract(sin(dot(p, vec2(127.1f, 311.7f))) * 43758.5453f);
}

float noise2(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    float a = hash21(i);
    float b = hash21(i + vec2(1.0f, 0.0f));
    float c = hash21(i + vec2(0.0f, 1.0f));
    float d = hash21(i + vec2(1.0f, 1.0f));
    vec2 u = f * f * (3.0f - 2.0f * f);
    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

float fbm(vec2 p) {
    float value = 0.0f;
    float amplitude = 0.5f;
    for (int i = 0; i < 5; ++i) {
        value += amplitude * noise2(p);
        p = p * 2.02f + vec2(11.5f, 7.2f);
        amplitude *= 0.5f;
    }
    return value;
}

float ridged_fbm(vec2 p) {
    float value = 0.0f;
    float amplitude = 0.5f;
    for (int i = 0; i < 5; ++i) {
        float n = noise2(p);
        float ridge = 1.0f - abs(2.0f * n - 1.0f);
        value += ridge * amplitude;
        p = p * 2.1f + vec2(9.2f, 3.4f);
        amplitude *= 0.5f;
    }
    return value;
}

// Main terrain height generation function
// Matches the algorithm in Landscape.vert
float terrain_height(vec2 p) {
    mat2 rot = mat2(0.866f, -0.5f, 0.5f, 0.866f);
    vec2 pr = rot * p;
    vec2 q = pr * 0.065f;
    vec2 warp = vec2(
        fbm(q * 1.15f + vec2(4.0f, 1.7f)),
        fbm(q * 1.15f + vec2(7.2f, 3.5f)));
    q += warp * 0.75f;

    float broad = fbm(q * 0.62f) * 3.6f;
    float base = fbm(q * 1.05f) * 2.2f;
    float ridge = ridged_fbm(q * 2.0f) * 4.2f;
    float crags = pow(max(ridged_fbm(q * 4.7f), 0.0f), 1.8f) * 1.15f;
    float macro = (sin(pr.x * 0.028f) + sin(pr.y * 0.024f)) * 0.85f;
    float detail = fbm(q * 7.6f) * 0.26f;

    float mountainMask = smoothstep(0.52f, 0.80f, ridged_fbm(q * 0.95f));
    float habitableLowlands = broad + base + macro;
    float mountainRelief = ridge + crags + detail;
    float lowlandBias = -0.55f * (1.0f - mountainMask);

    return habitableLowlands + mountainRelief * mountainMask + lowlandBias + 1.35f;
}

void main() {
    uint globalX = gl_GlobalInvocationID.x;
    uint globalY = gl_GlobalInvocationID.y;
    
    uint renderGridWidth = pushConstants.renderGridWidth;
    uint renderGridHeight = pushConstants.renderGridHeight;
    
    // Bounds check
    if (globalX >= renderGridWidth || globalY >= renderGridHeight) {
        return;
    }
    
    uint index = globalY * renderGridWidth + globalX;
    
    // Calculate grid position
    float gridWidth = float(ubo.gridXY.x);
    float gridHeight = float(ubo.gridXY.y);
    float startX = (gridWidth - 1.0f) / -2.0f;
    float startY = (gridHeight - 1.0f) / -2.0f;
    float subdivisions = float(pushConstants.renderSubdivisions);
    
    // Calculate vertex position in grid space
    float x = startX + float(globalX) / subdivisions;
    float y = startY + float(globalY) / subdivisions;
    // Note: waterRules.w stores the absolute_height (base surface Z position)
    // This is the starting Z before terrain height is applied
    float z = ubo.waterRules.w;
    
    // Calculate terrain height and apply it
    vec2 p = vec2(x, y);
    float height = terrain_height(p);
    z += height;
    
    // Write vertex to buffer
    vertices[index].position = vec3(x, y, z);
    vertices[index]._padding = 0.0f;
}

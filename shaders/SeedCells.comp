#version 450
#extension GL_GOOGLE_include_directive : enable

struct Cell {
    vec4 position;
    vec3 vertPosition;
    vec3 normal;
    vec4 color;
    ivec4 states;
};

layout(std430, binding = 1) buffer CellSSBOA { Cell cellA[]; };
layout(std430, binding = 2) buffer CellSSBOB { Cell cellB[]; };
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

#define UBO_LIGHT_NAME lightDirection
#include "ParameterUBO.glsl"

const vec4 white = vec4(1.0, 1.0, 1.0, 1.0);
const vec4 grey = vec4(0.5, 0.5, 0.5, 1.0);

uint hash_u32(uint x) {
    x ^= x >> 16;
    x *= 0x7feb352du;
    x ^= x >> 15;
    x *= 0x846ca68bu;
    x ^= x >> 16;
    return x;
}

uint ceil_log2_u32(uint x) {
    uint bits = 0u;
    uint value = max(x - 1u, 1u);
    while (value > 0u) {
        value >>= 1u;
        bits += 1u;
    }
    return bits;
}

uint feistel_permute(uint value, uint half_bits, uint key) {
    uint mask = (1u << half_bits) - 1u;
    uint left = value >> half_bits;
    uint right = value & mask;

    for (uint round = 0u; round < 5u; ++round) {
        uint round_key = key + 0x9e3779b9u * (round + 1u);
        uint f = hash_u32(right ^ round_key) & mask;
        uint new_left = right;
        uint new_right = (left ^ f) & mask;
        left = new_left;
        right = new_right;
    }

    return (left << half_bits) | right;
}

uint permute_to_range(uint index, uint total_cells, uint seed) {
    if (total_cells <= 1u) {
        return 0u;
    }

    uint log2_cells = ceil_log2_u32(total_cells);
    uint half_bits = (log2_cells + 1u) / 2u;
    uint domain_bits = half_bits * 2u;
    uint domain_size = 1u << domain_bits;

    uint value = index;
    for (uint iter = 0u; iter < 16u; ++iter) {
        value = feistel_permute(value, half_bits, seed + 0x85ebca6bu * iter);
        if (value < total_cells) {
            return value;
        }
    }

    return value % total_cells;
}

void main() {
    uint gridWidth = uint(max(ubo.gridXY.x, 1));
    uint gridHeight = uint(max(ubo.gridXY.y, 1));
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    if (x >= gridWidth || y >= gridHeight) {
        return;
    }

    uint index = y * gridWidth + x;
    uint totalCells = gridWidth * gridHeight;

    uint encodedTarget = uint(max(cellA[index].states.y, 0));
    uint targetAlive = min(encodedTarget, totalCells);
    uint seed = hash_u32(totalCells ^ 0x9e3779b9u);
    uint permuted = permute_to_range(index, totalCells, seed);

    bool isAlive = permuted < targetAlive;

    Cell seeded = cellA[index];
    seeded.position.w = isAlive ? (ubo.cellSize * 1.6) : 0.0;
    seeded.color = isAlive ? white : grey;
    seeded.states = ivec4(isAlive ? 1 : -1, -1, 0, 0);

    cellA[index] = seeded;
    cellB[index] = seeded;
}

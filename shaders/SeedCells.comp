#version 450
#extension GL_GOOGLE_include_directive : enable

struct Cell {
    vec4 position;
    vec3 vertPosition;
    vec3 normal;
    vec4 color;
    ivec4 states;
};

layout(std430, binding = 1) buffer CellSSBOA { Cell cellA[]; };
layout(std430, binding = 2) buffer CellSSBOB { Cell cellB[]; };
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

#define UBO_LIGHT_NAME lightDirection
#include "ParameterUBO.glsl"

const vec4 white = vec4(1.0, 1.0, 1.0, 1.0);
const vec4 grey = vec4(0.5, 0.5, 0.5, 1.0);

uint hash_u32(uint x) {
    x ^= x >> 16;
    x *= 0x7feb352du;
    x ^= x >> 15;
    x *= 0x846ca68bu;
    x ^= x >> 16;
    return x;
}

void main() {
    uint gridWidth = uint(max(ubo.gridXY.x, 1));
    uint gridHeight = uint(max(ubo.gridXY.y, 1));
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    if (x >= gridWidth || y >= gridHeight) {
        return;
    }

    uint index = y * gridWidth + x;
    uint totalCells = gridWidth * gridHeight;

    uint encodedTarget = uint(max(cellA[index].states.y, 0));
    uint targetAlive = min(encodedTarget, totalCells);

    float aliveRatio = float(targetAlive) / float(totalCells);
    uint threshold = uint(clamp(aliveRatio, 0.0, 1.0) * 4294967295.0);

    uint seed = hash_u32(totalCells ^ 0x9e3779b9u);
    uint mixed = index;
    mixed ^= x * 73856093u;
    mixed ^= y * 19349663u;
    mixed ^= seed;
    mixed = hash_u32(mixed);
    mixed = hash_u32(mixed ^ (x << 16) ^ y);

    bool isAlive = mixed <= threshold;

    Cell seeded = cellA[index];
    seeded.position.w = isAlive ? (ubo.cellSize * 1.6) : 0.0;
    seeded.color = isAlive ? white : grey;
    seeded.states = ivec4(isAlive ? 1 : -1, -1, 0, 0);

    cellA[index] = seeded;
    cellB[index] = seeded;
}
